[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Course Hub",
    "section": "",
    "text": "Content relevant to your course will be posted on the corresponding course pages which you can access from the list below or using side panel.\nNote that  it is your responsiblity to keep yourself updated  with any new developments and/or announcements."
  },
  {
    "objectID": "C0TimeSeriesandGIS/home_timeseriesandGIS.html",
    "href": "C0TimeSeriesandGIS/home_timeseriesandGIS.html",
    "title": "Time Series and GIS",
    "section": "",
    "text": "Source"
  },
  {
    "objectID": "C0TimeSeriesandGIS/home_timeseriesandGIS.html#time-series-in-r",
    "href": "C0TimeSeriesandGIS/home_timeseriesandGIS.html#time-series-in-r",
    "title": "Time Series and GIS",
    "section": "",
    "text": "Source"
  },
  {
    "objectID": "C0TimeSeriesandGIS/home_timeseriesandGIS.html#gis-in-r",
    "href": "C0TimeSeriesandGIS/home_timeseriesandGIS.html#gis-in-r",
    "title": "Time Series and GIS",
    "section": "GIS in R",
    "text": "GIS in R\n\n\nPackages to know\n\n\nsf, stars, terra"
  },
  {
    "objectID": "C0stochastic/brownian.html",
    "href": "C0stochastic/brownian.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "flowchart LR\n    markdown[\"`Random walk\"]\n    newLines[\"`Line1\n    Line 2\n    Line 3`\"]\n    markdown --&gt; newLines"
  },
  {
    "objectID": "C0stochastic/brownian.html#brownian-motion-as-a-markov-process",
    "href": "C0stochastic/brownian.html#brownian-motion-as-a-markov-process",
    "title": "Brownian Motion",
    "section": "Brownian motion as a markov process",
    "text": "Brownian motion as a markov process\n\\({X(t), t \\geq 0}\\).\n\nMarkov property: Prediction of process $X(s+t) with known information about \\(X(r), r \\leq s\\) depends only on X(s)"
  },
  {
    "objectID": "C0stochastic/brownian.html#filtration",
    "href": "C0stochastic/brownian.html#filtration",
    "title": "Brownian Motion",
    "section": "Filtration",
    "text": "Filtration\nDescribes the past of a process \\(X\\).\n\\[\nF_t = \\sigma {X(s), s \\in [0,t]}\n\\]"
  },
  {
    "objectID": "C0stochastic/brownian.html#resources",
    "href": "C0stochastic/brownian.html#resources",
    "title": "Brownian Motion",
    "section": "Resources",
    "text": "Resources\n\nOliver Ibe’s Markov processes for stochastic modeling"
  },
  {
    "objectID": "C0topology/home_topology.html",
    "href": "C0topology/home_topology.html",
    "title": "Topology",
    "section": "",
    "text": "Spaces"
  },
  {
    "objectID": "C0statanalysis/rainfall.html",
    "href": "C0statanalysis/rainfall.html",
    "title": "Rainfall",
    "section": "",
    "text": "Using the rainfall data and the grid in the quota DB:\n\nEstimate the total amount of rain on the Calabria-Basilicata area using kriging in a maximum likelihood framework. (choose variogram and trend)\ngiven a) build pointwise confidence intervals.\nmap results and comment output.\n\nan Rmarkdown with code and a few comments will be optimal."
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-4",
    "href": "C0statanalysis/rainfall.html#problem-4",
    "title": "Rainfall",
    "section": "",
    "text": "Using the rainfall data and the grid in the quota DB:\n\nEstimate the total amount of rain on the Calabria-Basilicata area using kriging in a maximum likelihood framework. (choose variogram and trend)\ngiven a) build pointwise confidence intervals.\nmap results and comment output.\n\nan Rmarkdown with code and a few comments will be optimal."
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-5",
    "href": "C0statanalysis/rainfall.html#problem-5",
    "title": "Rainfall",
    "section": "Problem 5",
    "text": "Problem 5\nUsing rainfall data prepare an R script that:\n\nimplement Bayesian kriging (krige.bayes, splm, JAGS…).\nevaluate estimates’ precision using credibility intervals.\ndiscuss your results and compare them to those obtained in homework 4."
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-6",
    "href": "C0statanalysis/rainfall.html#problem-6",
    "title": "Rainfall",
    "section": "Problem 6",
    "text": "Problem 6\nUsing Jags implement spatial interpolation of wolfcamp data on a 20x20 grid. In the implementation try to reduce the computational time as much as possible."
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-7",
    "href": "C0statanalysis/rainfall.html#problem-7",
    "title": "Rainfall",
    "section": "Problem 7",
    "text": "Problem 7\nUsing the  Sudden Infant Death data produce an R script to: 1. Compare pseudolikelihood estimates with those obtained using spautolm (library spdep) 2. Choose the “best” neighborhood structure for a CAR model on these data and justify your choice."
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-8",
    "href": "C0statanalysis/rainfall.html#problem-8",
    "title": "Rainfall",
    "section": "Problem 8",
    "text": "Problem 8\nUsing the data in the mite datasets (from library vegan in R) create the presence-absence variable for species ONOV and LCIL, then\n\nExplore the available variables (environmental variables are in the mite.env)\nBuild an autologistic model for each species choosing the best neighborhood structure\nDraw a predictive map for all models and for the simple logistic model.\nVerify the predictive ability of all models. Hint: use the example with the pepper trees plantation as an example"
  },
  {
    "objectID": "C0statanalysis/rainfall.html#problem-9",
    "href": "C0statanalysis/rainfall.html#problem-9",
    "title": "Rainfall",
    "section": "Problem 9",
    "text": "Problem 9\nUsing the data in file  dati_VE.mdb (or dati_VE.RData)\nGEV (Generalized extreme value distribution) model: 1) define an appropriate time window to use in maxima building (maxima should be iid)\n\nestimate the GEV model for each rainfall station and comment on possible differences.\ncompute return levels of order  100, 200, 500 e 1000\n\nGPD model: 4) on the same data estimate GPD model.\n\ncompute return levels of order 100, 200, 500 e 1000,\ndiscuss difference between the two approaches\n\n\n# datiAll &lt;- load(\"_data/datiAll.RData\")\n# rain &lt;- load(\"_data/RainData.RData\")\n\n\n# datiAll[\"sidscents\"]\n\n\n# library(ggplot2)\n# library(dplyr)\n# library(hrbrthemes)\n\n# Calabriaquota32 &lt;- rename(Calabriaquota32, c(XUTM=\"X\", YUTM = \"Y\"))\n\n# plotter &lt;- function(boundary, interior){\n#   # Plot the original XUTM and YUTM coordinates\n#   p &lt;- ggplot(boundary, aes(x = XUTM, y = YUTM)) +\n#     geom_point(color = \"black\") +\n#     labs(x = \"XUTM\", y = \"YUTM\", title = \"Bas\")\n  \n#   # Add the subset of specific coordinates colored by Quota\n#   p &lt;- p + geom_point(data = interior, aes(x = XUTM, y = YUTM, color = Quota)) +\n#     scale_color_gradient(low = \"blue\", high = \"red\") +  # Customize the color scale\n#     labs(color = \"Quota\") +\n#     theme_ipsum()\n  \n#   # Show the plot\n#   print(p)  \n  \n# }\n\n# plotter(Bas, Basquota32)\n# # plotter(Cal, Calabriaquota32)"
  },
  {
    "objectID": "test.html",
    "href": "test.html",
    "title": "Heading 1",
    "section": "",
    "text": "sdfds\n\n\nsdfds\n\n\nsdf\n\n\nsdfsd"
  },
  {
    "objectID": "test.html#heading-2",
    "href": "test.html#heading-2",
    "title": "Heading 1",
    "section": "",
    "text": "sdfds\n\n\nsdf\n\n\nsdfsd"
  },
  {
    "objectID": "test.html#head",
    "href": "test.html#head",
    "title": "Heading 1",
    "section": "Head",
    "text": "Head"
  },
  {
    "objectID": "C0financial/dataretrieval.html#using-edo",
    "href": "C0financial/dataretrieval.html#using-edo",
    "title": "Retrieving financial Data",
    "section": "Using edo",
    "text": "Using edo"
  },
  {
    "objectID": "C0manyBody/kohnsham.html",
    "href": "C0manyBody/kohnsham.html",
    "title": "Kohn Sham Equations",
    "section": "",
    "text": "There is an analogy that I’d like to create between the many body quantum electronic hamiltonian and the Kohn-Sham equations.\nLike all analogies it would be woefully skimpy on details but when I first started out I thought it was a useful way of looking at things. That and the fact that I like to recast equations into stories.\nConsider the complete many-body electronic hamiltonian:\n\\[\nMany body hamiltonian\n\\]\nI like to think of this way. We have a society of electrons that we would like to describe. The society might occupy these buildings which do not move.\nOf course buildings do move, say in response to earthquakes but most are stationary.\nTo explain that society of electrons in toto we need to find out about each and every member of that society.\nThis is akin to doing a thorough census. Or say a novel with a third person omniscient view in which the author, writes a gigantic Tolstoyan work, going into the motivations of every character.\nThat would be a detailed work and it would tell us what the society is fundamentally like, its ground state energy.\nBut say you are only interested in this fundamental aspect of society, not in the story of every single electron. Well what can you do?\nExactly what Kohn and Sham did.\nTo describe what the common denominator of that society is, you can move to a first person point of view.\nYou find out how that one member of society relates to other members of the society (taking society in a smeared out, abstracted sense). You find out how that one person interacts with all the buildings.\nBut since you are now not taking all the members your results would have an uncertainty. You would have to make presumptions to take into account the unique quirks of that individual.\nYou lump all that in the \\(E_XC\\) term. But if you’re making assumptions about what that unique person is then society’s interaction with that individual electron are mediated through his quirky behavior. So you have to explore his character, reducing his unique traits to a minimum.\nWhen you’ve removed all those contributions, in a sensible way you will have all the different mental states and moods of the central character of your novel.\nKohn-Sham are essentially saying that if you pin down an individual’s unique traits and are able to negate them, you will have the same picture of what the society is fundamentally like; that you would have had if you’d taken the sum over all the individual members."
  },
  {
    "objectID": "C0probtheory/home_probabilitytheory.html",
    "href": "C0probtheory/home_probabilitytheory.html",
    "title": "Probability Theory Home",
    "section": "",
    "text": "Motivation"
  },
  {
    "objectID": "C0probtheory/home_probabilitytheory.html#prbability-i",
    "href": "C0probtheory/home_probabilitytheory.html#prbability-i",
    "title": "Probability Theory Home",
    "section": "",
    "text": "Motivation"
  },
  {
    "objectID": "C0probtheory/03-FinitelyAdditiveMeasures.html",
    "href": "C0probtheory/03-FinitelyAdditiveMeasures.html",
    "title": "Finitely Additive Measures",
    "section": "",
    "text": "Instead of defining measures on full \\(\\sigma\\)-fields, we start with ‘weaker’ notions of measure."
  },
  {
    "objectID": "C0probtheory/03-FinitelyAdditiveMeasures.html#pre-measure-and-finitely-additive-measures",
    "href": "C0probtheory/03-FinitelyAdditiveMeasures.html#pre-measure-and-finitely-additive-measures",
    "title": "Finitely Additive Measures",
    "section": "Pre-measure and Finitely Additive Measures",
    "text": "Pre-measure and Finitely Additive Measures\n\nSuppose \\(A\\) is a field over \\(\\Omega\\) then \\((\\Omega, A)\\) is a Premeasurable Space\nA countably additive function \\(\\mu: A -&gt; [0, \\infty)\\) is a Premeasure\nIf \\(\\mu\\) is finitely additive then we use \\(\\chi\\) to represent it : \\(\\chi (A \\cup B) = \\chi(A) + \\chi(B)\\) then it is a Finitely Additive Measure\n\nCountable additivity is still difficult to construct."
  },
  {
    "objectID": "C0calculusI/home_calculusI.html",
    "href": "C0calculusI/home_calculusI.html",
    "title": "Calculus I",
    "section": "",
    "text": "This is the home page for calculus I (MT-101). All assignments, announcements, and other relevant materials will be posted here."
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#announcements",
    "href": "C0calculusI/home_calculusI.html#announcements",
    "title": "Calculus I",
    "section": "Announcements",
    "text": "Announcements"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#other-resources",
    "href": "C0calculusI/home_calculusI.html#other-resources",
    "title": "Calculus I",
    "section": "Other Resources",
    "text": "Other Resources\n\nPython related\n\nCalculus I in python"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html",
    "href": "C0calculusII/home_calculusII.html",
    "title": "Calculus II",
    "section": "",
    "text": "As announced in class, there will be a project.\nThe task: Reproduce 3 figures (two 2D and one 3D) from your textbook.\nNote that the figure must be accurate in terms of annotations and labels, tick marks, precision etc.\nFurthermore:\n\nThe project will be done in groups of 3.\nThe marks will be credited as bonus (i.e. they will not have a separate category)\nThere will be a viva in the 15th week.\nThe individual with the lowest midterm marks in the group will most likely give the viva (although other members of the group can be called upon too.)"
  },
  {
    "objectID": "C0calculusII/notebooks/11_2,3,4DotCrossProduct.html",
    "href": "C0calculusII/notebooks/11_2,3,4DotCrossProduct.html",
    "title": "Dot Product",
    "section": "",
    "text": "%matplotlib ipympl\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.widgets import Slider\n\n\n\n\n# Project vector v1 onto v2\ndef project(v1, v2):\n    return (np.dot(v1, v2) / np.dot(v2, v2)) * v2\n\n# Rotate vector\ndef rotate_vector(v, angle):\n    radians = np.deg2rad(angle)\n    rotation_matrix = np.array([\n        [np.cos(radians), -np.sin(radians)],\n        [np.sin(radians), np.cos(radians)]\n    ])\n    return np.dot(rotation_matrix, v)\n\ndef create_plot(xlim = (-6,6), ylim = (-6,6)):\n    fig, ax = plt.subplots()\n    plt.subplots_adjust(left=0.1, bottom=0.25)\n    ax.set_aspect('equal')\n    ax.set_xlim(-6, 6)\n    ax.set_ylim(-6, 6)\n    \n    return ax\n    \n\n\n# Initial vectors\nv1 = np.array([3, 2])\nv2 = np.array([3, 2]) * 1.3\n\n# Initial projection\nv1_proj = project(v1, v2)\n\n# Create plot\nax = create_plot(xlim = (-6,6), ylim = (-6,6))\n\n# Plot vector v1, vector v2, and the projection\nvector_v1, = ax.plot([0, v1[0]], [0, v1[1]], 'r', label='v1')\nvector_v2, = ax.plot([0, v2[0]], [0, v2[1]], 'cyan', label='v2')\nvector_proj, = ax.plot([0, v1_proj[0]], [0, v1_proj[1]], 'g--', label='Projection of v1 onto v2')\n\n# Slider for rotating v1\nax_angle = plt.axes([0.1, 0.1, 0.8, 0.05]) # [x0, y0] to [x1,y1]\nslider_angle = Slider(ax_angle, 'Angle', 0, 360, valinit=0)\n\n# Update function\ndef update(val):\n    \"\"\"\n    Updates when the slider is changed. \n\n    1. Read the slider value\n    2. Rotate the vector\n    3. Update v1 and its projection. v2 remains unchanged.\n    \"\"\"\n    \n    angle = slider_angle.val\n    v1_rot = rotate_vector(v1, angle)\n    v1_proj_rot = project(v1_rot, v2)\n    \n    vector_v1.set_xdata([0, v1_rot[0]])\n    vector_v1.set_ydata([0, v1_rot[1]])\n    vector_proj.set_xdata([0, v1_proj_rot[0]])\n    vector_proj.set_ydata([0, v1_proj_rot[1]])\n    \n    fig.canvas.draw_idle()\n\n# Call update function on slider value change\nslider_angle.on_changed(update)\n\n# Add legend and show plot\nax.legend()\nplt.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\npoints = 50\n\nx = np.linspace(0, 2 * np.pi, points)\ny = np.sin(x)\n\nfig, ax = plt.subplots()\nax.set_xlim(-0.3, 2 * np.pi + 0.3)\nax.set_ylim(-1.2, 1.2)\n\ndef animate(i):\n\n    if i == 0:\n#        fig.clear()\n        ax.plot(x[i], y[i], 'ro')\n    else:\n#        fig.clear()\n        ax.plot(x[i-1], y[i-1], 'bo')\n        ax.plot(x[i], y[i], 'ro')\n\nanim = FuncAnimation(fig, animate, frames=points, repeat=False, interval=150)\n\nplt.show()"
  },
  {
    "objectID": "C0calculusII/notebooks/10_1ParametricCurves.html",
    "href": "C0calculusII/notebooks/10_1ParametricCurves.html",
    "title": "Setup",
    "section": "",
    "text": "##You may need to run the following for animations:\n# !pip install ipympl\n\n\n## If you're using jupyter lab2\n# !pip install nodejs-bin\n# !jupyter labextension install @jupyter-widgets/jupyterlab-manager\n# !jupyter labextension install jupyter-matplotlib\n%matplotlib ipympl\nimport pandas as pd\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\n\nfrom sympy import plot_parametric, symbols, cos, sin\nfrom sympy import symbols\npd.set_option('display.precision', 2)"
  },
  {
    "objectID": "C0calculusII/notebooks/10_1ParametricCurves.html#examples",
    "href": "C0calculusII/notebooks/10_1ParametricCurves.html#examples",
    "title": "Setup",
    "section": " Examples",
    "text": "Examples\n\nExample 1: \\(\\quad x = sin(\\pi t/2),\\quad y=t, \\quad 0\\leq t\\leq 6\\)\n\nt = symbols('t')\nx = sin(sp.pi * t/2)\ny = t\n\np = plot_parametric((x, y), (t, 0, 6), show = False)\np.aspect_ratio=(1,1)\np.show()\n\nTypeError: 'str' object is not callable\n\n\n\n# Generate the table for specific values of t\n\ndef evaluate(x, s, values):\n    \"\"\"\n    Evaluate x on s, for num_values (given as a list) and return the result\n    \"\"\"    \n    return [round(float(x.evalf(subs={s: val})), 2) for val in values]\n\nvalues   = evaluate(t, t, list(range(7))) \nx_values = evaluate(x, t, values)\ny_values = evaluate(x, t, values)\n\n# Create a pandas DataFrame\ndata = {\n    't': t_values,\n    'x': x_values,\n    'y': y_values\n}\ndf = pd.DataFrame(data)\ndisplay(df)\n\n\n\n\n\n\n\n\nt\nx\ny\n\n\n\n\n0\n0\n0.0\n0.0\n\n\n1\n1\n1.0\n1.0\n\n\n2\n2\n0.0\n0.0\n\n\n3\n3\n-1.0\n-1.0\n\n\n4\n4\n-0.0\n-0.0\n\n\n5\n5\n1.0\n1.0\n\n\n6\n6\n0.0\n0.0\n\n\n\n\n\n\n\n\n## Using numpy\nt = np.linspace(0,6,7)\nx = np.sin(np.pi*t/2)\ny = t \n\npd.DataFrame([t,x,y]).T\n\nplt.plot(x,y)\nplt.gca().set_aspect('equal')\n\n\n\nExample 2\n\n\nExample 3\nYou may have seen the following equation. What does it represent? \\[\ny = ax - bx^2\n\\]\nWhere \\(a\\) and \\(b\\) are some constants.\nNow this equation can be parametrized into two equations as follows:  \\[\nx = ut, \\qquad y = vt + w t^2\n\\]  Where \\(u\\), \\(v\\), and \\(w\\) are constants related to \\(a\\) and \\(b\\). What are these equations showing?\n\nx, y, t = Symbol('x y t')\nu, v, w = Symbol('u v w')\n\nx = u*t\ny = v * t + w t^2\n\np = plot_parametric((x, y), (t, 0, 6), show = False)\n\n\n\nExample: Slider\n\n\nExample 3: Animate\n\n### Example Animate\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.animation as animation\n\nfig, ax = plt.subplots()\nt = np.linspace(0, 3, 40)\ng = -9.81\nv0 = 12\nz = g * t**2 / 2 + v0 * t\n\nv02 = 5\nz2 = g * t**2 / 2 + v02 * t\n\nscat = ax.scatter(t[0], z[0], c=\"b\", s=5, label=f'v0 = {v0} m/s')\nline2 = ax.plot(t[0], z2[0], label=f'v0 = {v02} m/s')[0]\nax.set(xlim=[0, 3], ylim=[-4, 10], xlabel='Time [s]', ylabel='Z [m]')\nax.legend()\n\n\ndef update(frame):\n    # for each frame, update the data stored on each artist.\n    x = t[:frame]\n    y = z[:frame]\n    # update the scatter plot:\n    data = np.stack([x, y]).T\n    scat.set_offsets(data)\n    # update the line plot:\n    line2.set_xdata(t[:frame])\n    line2.set_ydata(z2[:frame])\n    return (scat, line2)\n\n\nani = animation.FuncAnimation(fig=fig, func=update, frames=40, interval=20)\nplt.show()\n\n\n\n\n\nplt.close()\n\n\n\nGetting creative\n\n!jt -t chesterish\n\n\n!jt -r\n\nReset css and font defaults in:\n/home/fes33/.jupyter/custom &\n/home/fes33/.local/share/jupyter/nbextensions\n\n\n\n!jt -l\n\nAvailable Themes: \n   chesterish\n   grade3\n   gruvboxd\n   gruvboxl\n   monokai\n   oceans16\n   onedork\n   solarizedd\n   solarizedl\n\n\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot()\n\n[]\n\n\n\n\n\n\ndata = np.random.rand(180,1)\nnbnd = data.shape[0]\nlenk = int(data.shape[0] / nbnd)\nlenk\n\n1\n\n\n\ndata.shape[0] / 33\n\n5.454545454545454\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.ticker import (MultipleLocator, AutoMinorLocator)\n\n\nt = np.arange(0.0, 100.0, 0.1)\ns = np.sin(0.1 * np.pi * t) * np.exp(-t * 0.01)\n\nfig, ax = plt.subplots()\nax.plot(t, s)\n\n# Make a plot with major ticks that are multiples of 20 and minor ticks that\n# are multiples of 5.  Label major ticks with '.0f' formatting but don't label\n# minor ticks.  The string is used directly, the `StrMethodFormatter` is\n# created automatically.\nax.xaxis.set_major_locator(MultipleLocator(20))\nax.xaxis.set_major_formatter('{x:.2f}')\n\n# For the minor ticks, use no labels; default NullFormatter.\nax.xaxis.set_minor_locator(MultipleLocator(5))\n\nplt.show()"
  },
  {
    "objectID": "C0statmech/quantumgases.html",
    "href": "C0statmech/quantumgases.html",
    "title": "Quantum Gases",
    "section": "",
    "text": "graph TD\n    Q[Quantum Gases] --&gt; A[Ensembles]\n    A --&gt; B[Microcanonical Ensemble]\n    A --&gt; C[Canonical Ensemble]\n    A --&gt; D[Grand Canonical Ensemble]\n    Q --&gt; E[Partition Function]\n    Q --&gt; T[Thermodynamics]\n\n    SE(Shannon Entropy) --&gt; |Maximal|BE(Boltzmann Entropy)\nG\n\n  \n\nQuantum Gases\n\n Quantum Gases   \n\nEnsembles\n\n Ensembles   \n\nQuantum Gases–Ensembles\n\n   \n\nThermodynamics\n\n Thermodynamics   \n\nQuantum Gases–Thermodynamics\n\n   \n\nPartition Function\n\n Partition Function   \n\nQuantum Gases–Partition Function\n\n   \n\nMicrocanonical\n\n Microcanonical   \n\nEnsembles–Microcanonical\n\n   \n\nCanonical\n\n Canonical   \n\nEnsembles–Canonical\n\n   \n\nGrand Canonical\n\n Grand Canonical   \n\nEnsembles–Grand Canonical"
  },
  {
    "objectID": "C0statmech/quantumgases.html#microcanonical",
    "href": "C0statmech/quantumgases.html#microcanonical",
    "title": "Quantum Gases",
    "section": "Microcanonical",
    "text": "Microcanonical\nSee this and this\n\nCommon eigenstates\nPrinciple of uniform a priori probabilities\nEnergy shell\nMicrocanonical density operator\nInternal energy\nEntropy postulate\nPhase space volume"
  },
  {
    "objectID": "C0statmech/quantumgases.html#canonical",
    "href": "C0statmech/quantumgases.html#canonical",
    "title": "Quantum Gases",
    "section": "Canonical",
    "text": "Canonical"
  },
  {
    "objectID": "C0statmech/quantumgases.html#grand-canonical",
    "href": "C0statmech/quantumgases.html#grand-canonical",
    "title": "Quantum Gases",
    "section": "Grand Canonical",
    "text": "Grand Canonical"
  },
  {
    "objectID": "C0noneqthermo/linearresponsetheory.html",
    "href": "C0noneqthermo/linearresponsetheory.html",
    "title": "Linear Response Theory",
    "section": "",
    "text": "Non-equilibrium thermodynamics uses a phenomenological approach since enough information is not really available.\nG\n\n Formalism  \n\n1st + 2nd Law\n\n 1st + 2nd Law   \n\nGibbs equation\n\n Gibbs equation   \n\n1st + 2nd Law-&gt;Gibbs equation\n\n    \n\nRate of Entropy Production\n\n Rate of Entropy Production   \n\nGibbs equation-&gt;Rate of Entropy Production\n\n    \n\nLevel of Energy Dissipation\n\n Level of Energy Dissipation   \n\nRate of Entropy Production-&gt;Level of Energy Dissipation\n\n    \n\nBalance equations\n\n Balance equations   \n\nBalance equations-&gt;Rate of Entropy Production\nWe will not go far from equilibrium. The transport and rate equations will be expressed in linear forms, and the Onsager reciprocal relations are valid."
  },
  {
    "objectID": "C0noneqthermo/linearresponsetheory.html#stationary-states",
    "href": "C0noneqthermo/linearresponsetheory.html#stationary-states",
    "title": "Linear Response Theory",
    "section": "Stationary States",
    "text": "Stationary States\nIntensive properties that specify the state of a substance are time independent in equilibrium systems and in nonequilibrium stationary states (which only happens in non-isolated systems of course).\nExtensive properties specifying the state of a system with boundaries are also independent of time, and the boundaries are stationary in a coordinate system.\nThe stationary state of a substance at any point is related to the stationary state of the system\nThe total entropy will not change:\n\\[\n\\frac{dS}{dt} = \\frac{dS_e}{dt} + \\frac{dS_i}{dt} = 0\n\\]\nAlso in terms of entropy currents (in and out) a continuity equation can be written:\n\\[\n\\frac{dS_i}{dt} + (J_{s,in} - J_{s,out}) = 0\n\\]\n\n\n\\[\n\\begin{align}\n\\frac{dS_e}{dt} &= \\text{Entropy exchange between system and surroundings} \\\\\n\\frac{dS_i}{dt} &= \\text{Entropy production inside}\n\\end{align}\n\\]\nEntropy production (\\(dS_i \\geq 0\\)) and since \\(dS_e/dt\\) is greater than 0 (system need not be isolated):\n\\[\n\\frac{dS_e}{dt} = -\\frac{dS_i}{dt} = (J_{s,in} - J_{s,out}) &lt; 0\n\\]\n\n\nEntropy exchange with the environment is negative\n\n\nThe stationary state is maintained through the decrease in entropy exchanged between the system and its surrounding.\nThe total entropy produced within the system must be discharged across the boundary at stationary state.\n\n\n\n\n\n\n\n\n\nD\n\n Formalism  \n\nStationary state\n\n Stationary state   \n\nBoundary conditions do not change with time\n\n Boundary conditions do not change with time   \n\nStationary state-&gt;Boundary conditions do not change with time\n\n    \n\nIsolated system\n\n Isolated system   \n\nSteady state not possible\n\n Steady state not possible   \n\nIsolated system-&gt;Steady state not possible\n\n    \n\ndS_e/dt = 0\n\n dS_e/dt = 0   \n\nSteady state not possible-&gt;dS_e/dt = 0\n\n    \n\nEntropy created cannot be discharged to maintain steady state (dS_e/dt = 0)\n\n Entropy created cannot be discharged to maintain steady state (dS_e/dt = 0)   \n\nSteady state not possible-&gt;Entropy created cannot be discharged to maintain steady state (dS_e/dt = 0)\n\n    \n\nAdiabatic system\n\n Adiabatic system   \n\nAdiabatic system-&gt;Steady state not possible\n\n    \n\nEquilibrium\n\n Equilibrium   \n\ndS/dt = dS_e/dt = dS_i/dt = 0\n\n dS/dt = dS_e/dt = dS_i/dt = 0   \n\nEquilibrium-&gt;dS/dt = dS_e/dt = dS_i/dt = 0"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html",
    "href": "C0noneqthermo/home_noneqthermo.html",
    "title": "Non-equilibrium Thermodynamics",
    "section": "",
    "text": "Both the Fokker-Planck and Langevin equations describe the Brownian motion. In general, they also explain the behavior of a system in presence of a random noise and its evolution toward a stationary state i.e., they could also be applied to thermalization processes of non-equilibrium systems."
  },
  {
    "objectID": "0courses.html",
    "href": "0courses.html",
    "title": "Courses",
    "section": "",
    "text": "All pages grouped."
  },
  {
    "objectID": "0courses.html#non-equilibrium-physics",
    "href": "0courses.html#non-equilibrium-physics",
    "title": "Courses",
    "section": "Non-Equilibrium Physics",
    "text": "Non-Equilibrium Physics\nLangevin equation\\\nFokker Planck equation"
  },
  {
    "objectID": "0courses.html#probability-theory",
    "href": "0courses.html#probability-theory",
    "title": "Courses",
    "section": "Probability Theory",
    "text": "Probability Theory"
  },
  {
    "objectID": "0courses.html#statistical-field-theory",
    "href": "0courses.html#statistical-field-theory",
    "title": "Courses",
    "section": "Statistical Field Theory",
    "text": "Statistical Field Theory"
  },
  {
    "objectID": "0courses.html#bayesian-statistics",
    "href": "0courses.html#bayesian-statistics",
    "title": "Courses",
    "section": "Bayesian Statistics",
    "text": "Bayesian Statistics"
  },
  {
    "objectID": "0courses.html#gis",
    "href": "0courses.html#gis",
    "title": "Courses",
    "section": "GIS",
    "text": "GIS\nGIS"
  },
  {
    "objectID": "0courses.html#statistical-analysis",
    "href": "0courses.html#statistical-analysis",
    "title": "Courses",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\nRainfall"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "docs/C0stochastic/brownian.html",
    "href": "docs/C0stochastic/brownian.html",
    "title": "Brownian Motion",
    "section": "",
    "text": "flowchart LR\n    markdown[\"`Random walk\"]\n    newLines[\"`Line1\n    Line 2\n    Line 3`\"]\n    markdown --&gt; newLines"
  },
  {
    "objectID": "docs/C0stochastic/brownian.html#brownian-motion-as-a-markov-process",
    "href": "docs/C0stochastic/brownian.html#brownian-motion-as-a-markov-process",
    "title": "Brownian Motion",
    "section": "Brownian motion as a markov process",
    "text": "Brownian motion as a markov process\n\\({X(t), t \\geq 0}\\).\n\nMarkov property: Prediction of process $X(s+t) with known information about \\(X(r), r \\leq s\\) depends only on X(s)"
  },
  {
    "objectID": "docs/C0stochastic/brownian.html#filtration",
    "href": "docs/C0stochastic/brownian.html#filtration",
    "title": "Brownian Motion",
    "section": "Filtration",
    "text": "Filtration\nDescribes the past of a process \\(X\\).\n\\[\nF_t = \\sigma {X(s), s \\in [0,t]}\n\\]"
  },
  {
    "objectID": "docs/C0stochastic/brownian.html#resources",
    "href": "docs/C0stochastic/brownian.html#resources",
    "title": "Brownian Motion",
    "section": "Resources",
    "text": "Resources\n\nOliver Ibe’s Markov processes for stochastic modeling"
  },
  {
    "objectID": "C0noneqthermo/langevin.html",
    "href": "C0noneqthermo/langevin.html",
    "title": "Langevin Equation",
    "section": "",
    "text": "We are going to stochastically solve the Langevin Equation.\nWe take the Langevin equation. There is a stochastic force in there which is Gaussian in nature.\nWe will (1) use Euler’s method to generate a realization but for that we first need (2) a sampled Gaussian distribution.\nConsult Gerd Ropke’s text on non-equilibrium thermodynamics."
  },
  {
    "objectID": "C0noneqthermo/langevin.html#sampling-a-gaussian",
    "href": "C0noneqthermo/langevin.html#sampling-a-gaussian",
    "title": "Langevin Equation",
    "section": "Sampling a Gaussian",
    "text": "Sampling a Gaussian\n\nManually (Box-Fuller method)\nLet’s try the Box-Fuller method.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef SampleGaussian(num = 1000):\n\n    u = np.random.rand(num)\n    u1 = u[:int(num/2)]\n    u2 = u[int(num/2):]\n\n    z0 = np.sqrt(-2*np.log(u1)) * np.cos(2 * np.pi* u1)\n    z1 = np.sqrt(-2*np.log(u1)) * np.sin(2 * np.pi* u2)\n    z = np.concatenate((z0,z1))\n    return z\n\n\nplt.hist(SampleGaussian(), bins = 10)\n\n(array([  6.,  24., 209., 199., 318., 120.,  61.,  39.,  23.,   1.]),\n array([-2.82989146, -2.16441528, -1.4989391 , -0.83346292, -0.16798674,\n         0.49748944,  1.16296562,  1.8284418 ,  2.49391798,  3.15939416,\n         3.82487034]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\nAutomatic (use some library)"
  },
  {
    "objectID": "C0noneqthermo/langevin.html#numerical-solution-of-the-langevin-equation",
    "href": "C0noneqthermo/langevin.html#numerical-solution-of-the-langevin-equation",
    "title": "Langevin Equation",
    "section": "Numerical solution of the Langevin equation",
    "text": "Numerical solution of the Langevin equation\n\nUse the Euler method\n\\(v_k^{(m)} = v_{k-1}^{(m)} + h (-\\gamma v_{k-1}^{(m)} + r_{k-1}^{m})\\)\n$M = 1000 (Number of realizations), $ $N = 24000 time steps, $ $h = 0.025, $ \\(t_N - t_0 = 600 s,\\) \\(\\gamma = 5; D = 1\\)\n\n\nSolve it directly\n\nFor one realization: Create N random variables.\n\n\ndef eulerlangevin(vk_1, rk_1, h, gamma ):\n    return vk_1 + h * (-gamma * vk_1 + rk_1)\n\n\ndef langevinrealizations(h = 0.025, samples = 100, realizations = 10, v0 = 1, gamma = 5, D = 1):\n    \"\"\"\n    Create multiple langevin realizations\n    Arguments:\n        v0 = Initial velocity\n        h = time step\n        gamma = friction\n        D = Diffusion\n\n        time (not passed but total simulation time = h*samples)\n\n    \"\"\"\n\n    time = np.linspace(0,h*samples, samples)\n\n    allvk = np.empty((realizations, samples))\n    allgaussians = np.empty((realizations, samples))\n\n    for m in range(realizations):\n        gaussianrv = SampleGaussian(samples)\n        vk = np.array([])\n        for i in range(len(gaussianrv)):\n            if i == 0:\n                vk = np.array([v0]) #np.append(vk, eulerlangevin(v0, gaussianrv[0], h, gamma))\n            else:\n                vk = np.append(vk, eulerlangevin(vk[i-1], gaussianrv[i-1], h, gamma))\n\n        allvk[m] = vk\n        allgaussians[m] = gaussianrv\n\n    return time, allvk, allgaussians\ntime, allvk, allgaussians = langevinrealizations(samples = 1000, h = 0.025, gamma = 5, D = 1, realizations = 10)\n\nWe plot some realizations.\n\nn = 50\nplt.plot(time[:n], allvk[0][:n])\nplt.plot(time[:n], allvk[1][:n])\nplt.plot(time[:n], allvk[2][:n])"
  },
  {
    "objectID": "C0statmech/home_statmech.html",
    "href": "C0statmech/home_statmech.html",
    "title": "Statistical Mechanics",
    "section": "",
    "text": "Quantum Gases"
  },
  {
    "objectID": "jupyternotebooks/Untitled.html",
    "href": "jupyternotebooks/Untitled.html",
    "title": "WORLDLINES",
    "section": "",
    "text": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n## Sampling the Gaussian distribution using the Box-Muller Transform\n\n\nu = np.random.rand(1000)\nu1 = u[:500]\nu2 = u[500:]\n\n\nnp.pi\n\n3.141592653589793\n\n\n\nz0 = np.sqrt(-2*np.log(u1)) * np.cos(2 * np.pi* u1)\nz1 = np.sqrt(-2*np.log(u1)) * np.sin(2 * np.pi* u2)\nz = np.concatenate((z0,z1))\n\n\nplt.hist(z, bins = 10)\n\n\n\n\n(array([  4.,  14.,  50., 260., 236., 236., 104.,  54.,  34.,   8.]),\n array([-3.26780785, -2.58134183, -1.8948758 , -1.20840978, -0.52194376,\n         0.16452227,  0.85098829,  1.53745431,  2.22392034,  2.91038636,\n         3.59685238]),\n &lt;BarContainer object of 10 artists&gt;)"
  },
  {
    "objectID": "C0calculusII/notebooks/10_2CalculusonParametrization.html",
    "href": "C0calculusII/notebooks/10_2CalculusonParametrization.html",
    "title": "Calculus with Parametric Curves",
    "section": "",
    "text": "import sympy\n\nTangent lines and areas\nLength of a (parametrically defined) curve\n\nAreas of surfaces of revolution"
  },
  {
    "objectID": "C0calculusII/notebooks/10_6,7ConicSections.html",
    "href": "C0calculusII/notebooks/10_6,7ConicSections.html",
    "title": "Conic Sections",
    "section": "",
    "text": "pts = {                #Define High Symmetry Points\n    'gG1'   : 0,\n    'X1'    : 30,\n    'M1'    : 60,\n    'gG2'   : 90,\n    'R1'    : 120,\n    'X2|M2' : 150,\n    'R2'    : 180\n}\n\n\nlist(pts.keys())\n\n['gG1', 'X1', 'M1', 'gG2', 'R1', 'X2|M2', 'R2']\n\n\n\nk = list('abcdefghij')\nk\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n\n\nindex = [2,4,8]\nk = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\nlst = []\nfor ind in index:\n    lst.append(k[ind])\n\n\nlst = [k[ind] for ind in index]\nlst\n\n['c', 'e', 'i']\n\n\n\nlst\n\n['c', 'e', 'i']\n\n\n\na = list('1234567')\nb = list('ABCDEFG')\nc = list(zip(a,b))\n{el[1]: int(el[0]) for el in c}\n\n{'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7}\n\n\n\nhigh_symmetry_points = {            \n    'gG1'   : 0,\n    'X1'    : 30,\n    'M1'    : 60,\n    'gG2'   : 90,\n    'R1'    : 120,\n    'R2'    : 180\n}\n\n\n**high_symmetry_points\n\nSyntaxError: invalid syntax (151406231.py, line 1)\n\n\n\ndef fun(**kwargs):\n    if 'gg1' in kwargs.keys():\n        print(kwargs['gg1'])\n    return\n\n\nfun(gg2 = 'sdfs')"
  },
  {
    "objectID": "C0calculusII/notebooks/10_6,7ConicSections.html#conic-sections-in-polar-coordinates",
    "href": "C0calculusII/notebooks/10_6,7ConicSections.html#conic-sections-in-polar-coordinates",
    "title": "Conic Sections",
    "section": "",
    "text": "pts = {                #Define High Symmetry Points\n    'gG1'   : 0,\n    'X1'    : 30,\n    'M1'    : 60,\n    'gG2'   : 90,\n    'R1'    : 120,\n    'X2|M2' : 150,\n    'R2'    : 180\n}\n\n\nlist(pts.keys())\n\n['gG1', 'X1', 'M1', 'gG2', 'R1', 'X2|M2', 'R2']\n\n\n\nk = list('abcdefghij')\nk\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n\n\nindex = [2,4,8]\nk = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\nlst = []\nfor ind in index:\n    lst.append(k[ind])\n\n\nlst = [k[ind] for ind in index]\nlst\n\n['c', 'e', 'i']\n\n\n\nlst\n\n['c', 'e', 'i']\n\n\n\na = list('1234567')\nb = list('ABCDEFG')\nc = list(zip(a,b))\n{el[1]: int(el[0]) for el in c}\n\n{'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7}\n\n\n\nhigh_symmetry_points = {            \n    'gG1'   : 0,\n    'X1'    : 30,\n    'M1'    : 60,\n    'gG2'   : 90,\n    'R1'    : 120,\n    'R2'    : 180\n}\n\n\n**high_symmetry_points\n\nSyntaxError: invalid syntax (151406231.py, line 1)\n\n\n\ndef fun(**kwargs):\n    if 'gg1' in kwargs.keys():\n        print(kwargs['gg1'])\n    return\n\n\nfun(gg2 = 'sdfs')"
  },
  {
    "objectID": "C0calculusI/notebooks/01functions.html",
    "href": "C0calculusI/notebooks/01functions.html",
    "title": "Worldlines",
    "section": "",
    "text": "from sympy import symbols\n\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot()\n\n[]"
  },
  {
    "objectID": "C0probtheory/01-probmot.html",
    "href": "C0probtheory/01-probmot.html",
    "title": "Probability Motivation",
    "section": "",
    "text": "(See links below for resources)"
  },
  {
    "objectID": "C0probtheory/01-probmot.html#finite-vs.-countable",
    "href": "C0probtheory/01-probmot.html#finite-vs.-countable",
    "title": "Probability Motivation",
    "section": "Finite vs. Countable",
    "text": "Finite vs. Countable\nQuestion: Toss a coint till the first tail comes up. What is the probability that the number of tosses was odd?\nTake the sample space the set of all countably infinite sequences: \\[\n\\begin{aligned}\n\\Omega & = \\{(w_1, w_2, w_3, ...): w_j \\in \\{H,T\\}\\} \\\\\n& = \\{w: N \\rightarrow \\{H, T\\}\\}\n\\end{aligned}\n\\]\nProbability measures are countably additive"
  },
  {
    "objectID": "C0probtheory/01-probmot.html#probability-measure",
    "href": "C0probtheory/01-probmot.html#probability-measure",
    "title": "Probability Motivation",
    "section": "Probability Measure",
    "text": "Probability Measure"
  },
  {
    "objectID": "C0probtheory/01-probmot.html#resources",
    "href": "C0probtheory/01-probmot.html#resources",
    "title": "Probability Motivation",
    "section": "Resources",
    "text": "Resources\n\nLecture playlist"
  },
  {
    "objectID": "C0probtheory/01-probmot.html#glossary",
    "href": "C0probtheory/01-probmot.html#glossary",
    "title": "Probability Motivation",
    "section": "Glossary",
    "text": "Glossary\n\n\n\n\n\nterm\ndefinition\n\n\n\n\nCountable Additivity\nThe measure of the union of a countable number of nonoverlapping sets equals the sum of their measures. Allows summing of probabilities.Also called sigma-additivity (See: https://www.statlect.com/glossary/countable-additivity)"
  },
  {
    "objectID": "C0probtheory/02-sigmaFields.html",
    "href": "C0probtheory/02-sigmaFields.html",
    "title": "Sigma Fields/Algebras",
    "section": "",
    "text": "Remember that a sample space is \\(\\Omega\\) contains all possible outcomes. The probability measure takes subsets of \\(\\Omega\\) and maps them on to 0 and 1. But we might not want ALL subsets.\nThis is the p-value"
  },
  {
    "objectID": "C0probtheory/02-sigmaFields.html#glossary",
    "href": "C0probtheory/02-sigmaFields.html#glossary",
    "title": "Sigma Fields/Algebras",
    "section": "Glossary",
    "text": "Glossary\n\n\n\n\n\nterm\ndefinition\n\n\n\n\np-value\nThe probability of the observed data, or more extreme data, if the null hypothesis is true. The lower the p-value, the higher the test statistic, and less likely it is to observe the data if the null hypothesis is true."
  },
  {
    "objectID": "C0financial/home_financial.html",
    "href": "C0financial/home_financial.html",
    "title": "Financial Data Analysis (With pyspark)",
    "section": "",
    "text": "Data Retrieval"
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html",
    "href": "C0numericaltechniques/home_numericaltechniques.html",
    "title": "Non-equilibrium Thermodynamics",
    "section": "",
    "text": "Nonlinear coupled differential equations arise in various fields, such as physics, engineering, biology, and economics. Solving them can be challenging due to the complexity introduced by nonlinearity and coupling between the equations. Here are several techniques and methods commonly used to solve such equations:"
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#exact-solutions",
    "href": "C0numericaltechniques/home_numericaltechniques.html#exact-solutions",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Exact Solutions:",
    "text": "Exact Solutions:\n    Separation of Variables: If the equations can be separated into simpler, independent equations.\n\n    Transform Methods: Techniques like Laplace and Fourier transforms can sometimes linearize and decouple the equations.\n\n    Integrating Factors: Useful for first-order nonlinear equations.\n\n    Symmetry Methods: Exploiting symmetries of the equations to find exact solutions."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#perturbation-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#perturbation-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Perturbation Methods:",
    "text": "Perturbation Methods:\n    Regular Perturbation: Assumes a small parameter in the system to expand the solution as a power series.\n\n    Singular Perturbation: Deals with problems where small parameters multiply the highest derivatives."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#variational-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#variational-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Variational Methods:",
    "text": "Variational Methods:\n    Euler-Lagrange Equations: For systems that can be described by a variational principle."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#finite-difference-method-fdm",
    "href": "C0numericaltechniques/home_numericaltechniques.html#finite-difference-method-fdm",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Finite Difference Method (FDM):",
    "text": "Finite Difference Method (FDM):\nExplicit and Implicit Methods: Discretize the equations on a grid and use iterative schemes to solve.\n\nCrank-Nicolson Method: A mix of explicit and implicit methods, often used for time-dependent problems."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#finite-element-method-fem",
    "href": "C0numericaltechniques/home_numericaltechniques.html#finite-element-method-fem",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Finite Element Method (FEM):",
    "text": "Finite Element Method (FEM):\nGalerkin Method: Projects the problem onto a finite-dimensional space using basis functions.\n\nMesh Generation: Divides the domain into smaller regions (elements) to solve the problem locally."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#finite-volume-method-fvm",
    "href": "C0numericaltechniques/home_numericaltechniques.html#finite-volume-method-fvm",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Finite Volume Method (FVM):",
    "text": "Finite Volume Method (FVM):\nConserves quantities through discretization by integrating the equations over control volumes."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#spectral-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#spectral-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Spectral Methods:",
    "text": "Spectral Methods:\nFourier Spectral Methods: Expand the solution in terms of global basis functions like Fourier series.\n\nChebyshev Spectral Methods: Use Chebyshev polynomials as basis functions."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#runge-kutta-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#runge-kutta-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Runge-Kutta Methods:",
    "text": "Runge-Kutta Methods:\nExplicit and Implicit Runge-Kutta: Time-stepping methods for initial value problems.\n\nAdaptive Runge-Kutta: Adjusts the step size based on the error estimate to improve efficiency."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#multistep-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#multistep-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Multistep Methods:",
    "text": "Multistep Methods:\nAdams-Bashforth and Adams-Moulton: Use multiple past points to estimate the next point in time-stepping."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#shooting-method",
    "href": "C0numericaltechniques/home_numericaltechniques.html#shooting-method",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Shooting Method:",
    "text": "Shooting Method:\nConverts boundary value problems into initial value problems by guessing the initial conditions."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#newtons-method-for-systems",
    "href": "C0numericaltechniques/home_numericaltechniques.html#newtons-method-for-systems",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Newton’s Method for Systems:",
    "text": "Newton’s Method for Systems:\nAn iterative method to solve nonlinear algebraic equations resulting from discretization."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#continuation-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#continuation-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Continuation Methods:",
    "text": "Continuation Methods:\nPseudo-Arclength Continuation: Tracks solution paths as parameters vary.\n\nHomotopy Continuation: Connects a difficult problem to an easier one via a continuous path."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#stochastic-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#stochastic-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Stochastic Methods:",
    "text": "Stochastic Methods:\nMonte Carlo Methods: Useful for systems with probabilistic components.\n\nGenetic Algorithms: Optimization techniques inspired by natural selection."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#domain-decomposition-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#domain-decomposition-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Domain Decomposition Methods:",
    "text": "Domain Decomposition Methods:\nSchwarz Alternating Method: Decomposes the domain into smaller subdomains and solves iteratively."
  },
  {
    "objectID": "C0numericaltechniques/home_numericaltechniques.html#multi-grid-methods",
    "href": "C0numericaltechniques/home_numericaltechniques.html#multi-grid-methods",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Multi-Grid Methods:",
    "text": "Multi-Grid Methods:\nSolves the problem on multiple grids with different resolutions to accelerate convergence."
  },
  {
    "objectID": "C0topology/01-spaces.html",
    "href": "C0topology/01-spaces.html",
    "title": "Spaces",
    "section": "",
    "text": "This is the p-value"
  },
  {
    "objectID": "C0topology/01-spaces.html#glossary",
    "href": "C0topology/01-spaces.html#glossary",
    "title": "Spaces",
    "section": "Glossary",
    "text": "Glossary\n\n\n\n\n\nterm\ndefinition\n\n\n\n\np-value\nThe probability of the observed data, or more extreme data, if the null hypothesis is true. The lower the p-value, the higher the test statistic, and less likely it is to observe the data if the null hypothesis is true."
  },
  {
    "objectID": "C0stochastic/home_stoch.html",
    "href": "C0stochastic/home_stoch.html",
    "title": "Stochastic Processes",
    "section": "",
    "text": "Brownian Motion"
  },
  {
    "objectID": "C0TimeSeriesandGIS/GIS/01gis.html",
    "href": "C0TimeSeriesandGIS/GIS/01gis.html",
    "title": "Basic tasks in GIS using R",
    "section": "",
    "text": "Test"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#quizzes-and-assignments",
    "href": "C0calculusI/home_calculusI.html#quizzes-and-assignments",
    "title": "Calculus I",
    "section": "Quizzes and Assignments",
    "text": "Quizzes and Assignments\nWe will most likely have three quizzes. Tentatively:\n\nQuiz 1 (5 marks, 4th week)\n\nQuiz 2 (10 marks, 7th week)\n\nQuiz 3 (10 marks, 13th week)\n\n\nN.B.: If you can’t take the quiz for some reason, you need to inform us in advance."
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#course-outline",
    "href": "C0calculusI/home_calculusI.html#course-outline",
    "title": "Calculus I",
    "section": "Course Outline",
    "text": "Course Outline\nOutline (pdf)"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#slides-and-notebooks",
    "href": "C0calculusI/home_calculusI.html#slides-and-notebooks",
    "title": "Calculus I",
    "section": "Slides and Notebooks",
    "text": "Slides and Notebooks\nNote: You may need to setup python and sympy. You can either see an online tutorial for that, or consult me.\nIf you want a quick solution, then you can use sympy on Google colab as shown here\n\n\nFunctions\nLimits and Continuity"
  },
  {
    "objectID": "C0calculusI/lectures/test.html",
    "href": "C0calculusI/lectures/test.html",
    "title": "Test",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nplt.plot()\n\n[]\n\n\n\n\n\n\\[\nx = 3 + y\n\\]"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#quizzes-and-assignments",
    "href": "C0calculusII/home_calculusII.html#quizzes-and-assignments",
    "title": "Calculus II",
    "section": "",
    "text": "We will most likely have three quizzes. Tentatively:\nQuiz 1 (5 marks, 4th week)\nQuiz 2 (10 marks, 7th week)\nQuiz 3 (10 marks, 13th week)"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#slides-and-notebooks",
    "href": "C0calculusII/home_calculusII.html#slides-and-notebooks",
    "title": "Calculus II",
    "section": "Slides and Notebooks",
    "text": "Slides and Notebooks\nNote: You may need to setup python and sympy. You can either see an online tutorial for that, or consult me.\nIf you want a quick solution, then you can use sympy on Google colab as shown here\n\nParametric Curves\nParametric Curves Calculus\nParametric Curves Polar\nConic Sections\nVectors\nQuadric Surfaces\nPartial Derivatives\nDouble Integrals"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#course-outline",
    "href": "C0calculusII/home_calculusII.html#course-outline",
    "title": "Calculus II",
    "section": "Course Outline",
    "text": "Course Outline\nOutline (pdf)"
  },
  {
    "objectID": "C0calculusII/lectures/10_1ParametricPlots.html",
    "href": "C0calculusII/lectures/10_1ParametricPlots.html",
    "title": "Parametric Plots",
    "section": "",
    "text": "Basic parametrizations\n\n\n\n\nSome plotting routines. Click to expand\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plotter(x, y, create = False):\n    if create: plt.figure(figsize=(6, 6))\n    plt.plot(x, y)\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    return\n\ndef centeraxes():\n    ax = plt.gca()\n    # Move left y-axis and bottom x-axis to centre, passing through (0,0)\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n\n    # Eliminate upper and right axes\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n\n    # Show ticks in the left and lower axes only\n    ax.xaxis.set_ticks_position('bottom')\n    ax.yaxis.set_ticks_position('left')\n    return\n\n\n\nParabola\n\n\nCircle and Ellipse\n\nt = np.linspace(0, 2 * np.pi, 400)\n\nx = np.cos(t)\ny = np.sin(t)\nplotter(x,y, create = True)\n\nx = 2* np.cos(t)\ny = np.sin(t)\nplotter(x,y)\ncenteraxes()\nplt.show()\n\n\n\n\n\n\nHyperpola\n\nt = np.linspace(0.1, 10, 400)\n\nx = t + 1/t\ny = t - 1/t\nplotter(x,y)\ncenteraxes()\n\nplt.show()\n\n\n\n\n\n\nCycloid\n\nt = np.linspace(0, 8*np.pi, 400)\n\na = 1\n\nx = a * (t - np.sin(t))\ny = a * (1 - np.cos(t))\nplotter(x,y)\ncenteraxes()\n\nplt.show()\n\n\n\n\n\n\nBrachistochrone and Tautochrone\n\n\n\n\n\nMiscellaneous\n\n\nDrawing the Batman curve.\n\n\nNon-parametric version\nimport numpy as np\nimport matplotlib.pyplot as plt\nx = np.linspace(-6,6,1000)\n\ndef sf(x):\n    return np.sqrt(1-x**2)                           # semicircle\ndef ef(x):\n    return 3*sf(x/7)                             # ellipse\ndef sh(x):\n    return 4.2 - .5*x -2.8*sf(.5*x -.5)          # shoulders\ndef bf(x):\n    return sf(abs(2 - x) - 1) - x**2/11 + .5*x -3 # bottom\n\ncl_x = [0,0.5,0.8,1]\ncl_xn = [-x for x in cl_x]\ncl_y = [1.7, 1.7, 2.6, 0.9]\n\ndef p(f,xmin,xmax, flipy = False):\n    \"symmetric plot across y-axis\"\n    \n    x = np.linspace(xmin, xmax, 100)\n    y = f(x)\n    if flipy: \n        y = -y\n    p1 = plt.plot(x, y)\n    \n    x = [-i for i in x]\n    ax = plt.plot(x, y)\n    \n    return ax\n\np(ef,3,7) \np(ef,4,7, flipy = True) \np(sh,1,3)\np(bf,0,4) \nplt.plot(cl_x, cl_y)\nplt.plot(cl_xn, cl_y)\nplt.show()\n\n\n\n\n\nBelow is a parametrized version of the plot.\n\n\nParametric version\nimport sympy as sm\n\n\nx = sm.symbols('x', real=True)\nh_ = sm.symbols('h_')\n\nw = 3 * sm.sqrt(1 - (x / 7)**2)\nl = ((x + 3) / 2 - sm.S(3) / 7 * sm.sqrt(10) * sm.sqrt(4 - (x + 1)**2) +\n        sm.S(6) / 7 * sm.sqrt(10))\nr = ((3 - x) / 2 - sm.S(3) / 7 * sm.sqrt(10) * sm.sqrt(4 - (x - 1)**2) +\n        sm.S(6) / 7 * sm.sqrt(10))\nh = (3*(sm.Abs(x - sm.S.Half) + sm.Abs(x + sm.S.Half) + 6) -\n                11*(sm.Abs(x - sm.S(3)/4) + sm.Abs(x + sm.S(3)/4)))/2 \nf = ((h - l) * sm.Heaviside(x + 1, 0) +\n        (r - h) * sm.Heaviside(x - 1, 0) +\n        (l - w) * sm.Heaviside(x + 3, 0) +\n        (w - r) * sm.Heaviside(x - 3, 0) + \n        w)\ng = (sm.S(1) / 2 * (sm.Abs(x / 2) + sm.sqrt(1 - (sm.Abs(sm.Abs(x) - 2) -\n        1)**2) - sm.S(1) / 112 * (3 * sm.sqrt(33) - 7) * x**2 + 3 *\n        sm.sqrt(1 - (sm.S(1) / 7 * x)**2) - 3) * ((x + 4) / sm.Abs(x + 4) -\n        (x - 4) / sm.Abs(x - 4)) - 3 * sm.sqrt(1 - (x / 7)**2))\nsm.plot(f, g)\n\n\n&lt;lambdifygenerated-3&gt;:2: RuntimeWarning: invalid value encountered in sqrt\n  return -3*sqrt(1 - 1/49*x**2) + (-(x - 4)/abs(x - 4) + (x + 4)/abs(x + 4))*(-1/2*x**2*(-1/16 + (3/112)*sqrt(33)) + (3/2)*sqrt(1 - 1/49*x**2) + (1/2)*sqrt(1 - (abs(abs(x) - 2) - 1)**2) + (1/4)*abs(x) - 3/2)\n\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x1515a06c8be0&gt;\n\n\nThe bottom wings are missing. Most likely some part of the equation is missing. You can experiment with the equations if you want.\n\n\n\nTaken from Math World"
  },
  {
    "objectID": "C0calculusII/notebooks/10_1aParametricCurvesAnimated.html",
    "href": "C0calculusII/notebooks/10_1aParametricCurvesAnimated.html",
    "title": "Worldlines",
    "section": "",
    "text": "import sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom ipywidgets import FloatSlider, interact\nfrom IPython.display import display\n\n# Define the symbolic variables and parametric equations\nt = sp.Symbol('t')\nx = sp.cos(t)\ny = sp.sin(t)\n\n# Convert the parametric equations to a numerical function\nf_x = sp.lambdify(t, x, 'numpy')\nf_y = sp.lambdify(t, y, 'numpy')\n\n# Generate the values for the curve\nt_values = np.linspace(0, 2 * np.pi, 400)\nx_values = f_x(t_values)\ny_values = f_y(t_values)\n\n# Set up the plot\nfig, ax = plt.subplots()\nline, = ax.plot(x_values, y_values, lw=2)\ndot, = ax.plot([], [], 'ro')  # The red dot indicating the position\n\n# Set plot limits\nax.set_xlim(-1.5, 1.5)\nax.set_ylim(-1.5, 1.5)\nax.set_aspect('equal')\n\n# Update function for the slider\ndef update(t_val):\n    x_val = f_x(t_val)\n    y_val = f_y(t_val)\n    dot.set_data([x_val], [y_val])  # Update the dot position\n    fig.canvas.draw_idle()\n\n# Create the slider and display it\nslider = FloatSlider(value=0, min=0, max=2 * np.pi, step=0.01, description='t')\ninteract(update, t_val=slider)\n\n# Display the plot\nplt.show()"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html",
    "href": "C0calculusI/lectures/1functions.html",
    "title": "Functions",
    "section": "",
    "text": "Read: Chapter 1"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html#terminology",
    "href": "C0calculusI/lectures/1functions.html#terminology",
    "title": "Functions",
    "section": "Terminology",
    "text": "Terminology\nFollowing is a list of terms that you should know the meaning of.\n\nWhat are functions?\n\nVertical line test for a function.\nPiece-wise defined functions\n\nIndependent vs. dependent variables.\nDomain vs. range.\n\nClosed vs. open intervals"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html#some-special-functions",
    "href": "C0calculusI/lectures/1functions.html#some-special-functions",
    "title": "Functions",
    "section": "Some special functions",
    "text": "Some special functions\n\nLinear functions\n\n\nAbsolute value function/Modulus\n\n\nPower functions\n\n\nPolynomials\n\n\nRational functions\n\n\nAlgebraic functions\n\n\nTrigonometric functions\n\nimport sympy as sp\n\n# Define the variable\nx = sp.Symbol('x')\n\nfunc1 = sp.cos(x)\nfunc2 = sp.sec(x)\n\nfunc3 = sp.sin(x)\nfunc4 = sp.csc(x)\n\nfunc5 = sp.tan(x)\nfunc6 = sp.cot(x)\n# Define the piecewise function\n\n# Display the piecewise function\nsp.plot(func2, func3, (x,-4*sp.pi,4*sp.pi), ylim = (-2,2))\n\nsp.plot(func5, (x,-4*sp.pi,4*sp.pi), ylim = (-10,10))\n\n\n\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x146bc48345e0&gt;\n\n\n\n\nInverse Trigonometric\n\nimport sympy as sp\n\n# Define the variable\nx = sp.Symbol('x')\n\nfunc1 = sp.acos(x)\nfunc2 = sp.asec(x)\n\nfunc3 = sp.asin(x)\nfunc4 = sp.acsc(x)\n\nfunc5 = sp.atan(x)\nfunc6 = sp.acot(x)\n# Define the piecewise function\n\n# Display the piecewise function\nsp.plot(func2, func3, (x,-4*sp.pi,4*sp.pi), ylim = (-2,2))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x146bc4850910&gt;\n\n\n\n\nExponential functions\n\n\nLogarithmic functions\n\n\nTranscendental functions\n\n\nPiecewise\n\nimport sympy as sp\n\n# Define the variable\nx = sp.Symbol('x')\n\n# Define the piecewise function\npiecewise_func = sp.Piecewise(\n    (x**2, x &lt; 0),        # x^2 when x &lt; 0\n    (x + 1, (x &gt;= 0) & (x &lt;= 2)),  # x + 1 when 0 &lt;= x &lt;= 2\n    (x**3, x &gt; 2)         # x^3 when x &gt; 2\n)\n\n# Display the piecewise function\nsp.plot(piecewise_func, (x,-3,3))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x146bc4850700&gt;"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html#some-special-functions.colorred",
    "href": "C0calculusI/lectures/1functions.html#some-special-functions.colorred",
    "title": "Functions",
    "section": "[Some special functions]{.color=red}",
    "text": "[Some special functions]{.color=red}\n\nAbsolute value function/Modulus"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html#functions-some-properties",
    "href": "C0calculusI/lectures/1functions.html#functions-some-properties",
    "title": "Functions",
    "section": "Functions: Some properties",
    "text": "Functions: Some properties\n\nIncreasing vs. decreasing\nEven vs. odd\nLinear vs. non-linear"
  },
  {
    "objectID": "index.html#text",
    "href": "index.html#text",
    "title": "Course Hub",
    "section": "",
    "text": "Content relevant to your course will be posted on the corresponding course pages which you can access from the list below or using side panel.\nNote that  it is your responiblity to keep yourself updated  with any new developments and/or announcements.\nCalculus I - MT101\nCalculus II - MT202"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#contacts",
    "href": "C0calculusI/home_calculusI.html#contacts",
    "title": "Calculus I",
    "section": "Contacts",
    "text": "Contacts\nIn case of queries regarding attendance, quizzes, and assignments contact:\nMr. Hassan Ali\nEmail: hassan.ali@giki.edu.pk\nMr. Aamir Shehzad\nEmail: aamir.shehzad@giki.edu.pk"
  },
  {
    "objectID": "C0calculusI/lectures/1functions.html#plotting-functions",
    "href": "C0calculusI/lectures/1functions.html#plotting-functions",
    "title": "Functions",
    "section": "Plotting functions",
    "text": "Plotting functions\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef centeraxes():\n  \"\"\"Centers axes in the middle\"\"\"\n  ax = plt.gca()\n  ax.spines['top'].set_color('none')\n  ax.spines['left'].set_position('zero')\n  ax.spines['right'].set_color('none')\n  ax.spines['bottom'].set_position('zero')\n  return ax\n\nWe can plot a single function as follows:\n\ndomain = np.linspace(-5,5, 1000)\nfunc = np.sqrt(domain)\n\n# plt.plot(domain, func)\n# plt.plot(domain, func2)\nplt.plot(domain, func)\nplt.gca().set_aspect('equal')\n\ncenteraxes()\n\nplt.show()\n\n/tmp/ipykernel_218466/1562034490.py:2: RuntimeWarning: invalid value encountered in sqrt\n  func = np.sqrt(domain)\n\n\n\n\n\nBut we can also plot multiple functions, although this is not necessarily the neatest way, Matplotlib changes colors by default (but we can control it too):\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndomain = np.linspace(-1,1, 1000)\nfunc = domain**2\nfunc2 = domain**3\nfunc3 = np.cos(domain)\nfunc4 = np.sqrt(domain)\n\nplt.plot(domain, func)\nplt.plot(domain, func2)\nplt.plot(domain, func3)\nplt.plot(domain, func4)\nplt.gca().set_aspect('equal')\n\ncenteraxes()\n\nplt.show()\n\n/tmp/ipykernel_218466/3654791602.py:8: RuntimeWarning: invalid value encountered in sqrt\n  func4 = np.sqrt(domain)"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Course Hub",
    "section": "Contact",
    "text": "Contact\nsheharyar [at] giki.edu.pk\nOffice (G-27, FES)\nConsultation hours (9 to 10 am, Mon to Fri)"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#teaching-assistants",
    "href": "C0calculusII/home_calculusII.html#teaching-assistants",
    "title": "Calculus II",
    "section": "Teaching Assistants",
    "text": "Teaching Assistants\nIn case of queries regarding attendance, quizzes, and assignments contact:\nMs. Iqra Anjum\nEmail: ges2319@giki.edu.pk"
  },
  {
    "objectID": "C0calculusII/notebooks/temp/test.html",
    "href": "C0calculusII/notebooks/temp/test.html",
    "title": "Rough work",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n## Using numpy\nfrom numpy import sin, cos, tan\n\nt = [0, 12]\nt = np.linspace(t[0],t[1],1000)\n\nx = t* np.sin(np.pi*t/2)\ny = t* np.cos(np.pi*t/2) \n\npd.DataFrame([t,x,y]).T\n\nplt.plot(x,y)\nplt.gca().set_aspect('equal')"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html",
    "title": "Calculus with Parametric Curves",
    "section": "",
    "text": "Some plotting routines. Click to expand\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom sympy import plot_parametric, symbols\nfrom IPython.display import display, Markdown\nfrom functools import partial\n\n## This is a 'partial function' so that we don't have to set figure size and aspect ratio every time.\nsplot = partial(plot_parametric, aspect_ratio = (1,1),size=(4,4),axis_center = (0,0))\n\n\n\ndef _plotter(x, y, create = False):\n    if create: plt.figure(figsize=(6, 6))\n    plt.plot(x, y)\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    return\n\ndef _centeraxes():\n    ax = plt.gca()\n    # Move left y-axis and bottom x-axis to centre, passing through (0,0)\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n\n    # Eliminate upper and right axes\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n\n    # Show ticks in the left and lower axes only\n    ax.xaxis.set_ticks_position('bottom')\n    ax.yaxis.set_ticks_position('left')\n    return\n\ndef _displayM(text, expr):\n  \"\"\"\n  Display text and expression inline. \n  \"\"\"\n  display(Markdown('{} {}'.format(\n            text,\n            sp.latex(expr, mode='inline')\n          ))\n  )"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#integration-and-differentiation-via-python",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#integration-and-differentiation-via-python",
    "title": "Calculus with Parametric Curves",
    "section": "Integration and Differentiation via python",
    "text": "Integration and Differentiation via python\nA quick reminder, you can perform differentiation and integration (definite or indefinite) as follows:\n\nimport sympy as sp\nx, y, z = sp.symbols('x y z')\n\nf = sp.cos(x)**3\n\nresult = sp.diff(f)\nresult\n## To evaluate a function, substitute the value of x.\n# result.subs(x,sp.pi/3)\n\n\\(\\displaystyle - 3 \\sin{\\left(x \\right)} \\cos^{2}{\\left(x \\right)}\\)\n\n\n\ninf = sp.oo\n\nx, y, z = sp.symbols('x y z')\n\n# Indefinite integrals\nf = sp.ln(x)\nsp.integrate(f,x)\n\n# Definite integrals\nsp.integrate(sp.exp(-x), (x, 0, inf))\n\n\\(\\displaystyle 1\\)\n\n\n\n\n\n\n\n\nWarning\n\n\n\n\n\nIf integrate is unable to compute an integral, it returns an unevaluated Integral object."
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#tangent-lines",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#tangent-lines",
    "title": "Calculus with Parametric Curves",
    "section": "Tangent Lines",
    "text": "Tangent Lines\n\nExample 1:\nFind the tangent to the line \\(x = sec(t), y = tan(t)\\) at \\((\\sqrt(2),1)\\) where \\(t=\\pi/4\\).\n\nt = symbols('t')\n\nf = sp.sec(t)\ng = sp.tan(t)\n\nsplot((f, g), (t, -sp.pi/3, sp.pi/3))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14c3a2087d90&gt;\n\n\nNow we need to find the slope:\n\nevalat = sp.pi/4\n\ndy_dx = sp.diff(g)/sp.diff(f)\nslope = dy_dx.subs(t, evalat)\n\ndisplay(dy_dx)\ndisplay(slope)\n\n\\(\\displaystyle \\frac{\\tan^{2}{\\left(t \\right)} + 1}{\\tan{\\left(t \\right)} \\sec{\\left(t \\right)}}\\)\n\n\n\\(\\displaystyle \\sqrt{2}\\)\n\n\nSo our tangent is a line passing through \\((\\sqrt{2},1)\\) with slope {python} slope. Let’s plot the curve and this tangent line together.\n\n# From question\nx0, y0 = sp.sqrt(2), 1\n\n## Parametric representation of a line\nx   = t\ny_t = slope * (t - x0) + y0\n\n## Plot both the curve and the tangent.\nsplot((f, g,    (t, -sp.pi/3, sp.pi/3)), \n      (t, y_t,  (t, 0, 2)),\n      )\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14c3a219f460&gt;\n\n\nStep 1 Find \\(dy/dx\\) at the said point.\n\\[\n\\frac{dy}{dx} = \\frac{\\sec{t}}{\\tan{t}} = \\csc{t}\n\\]"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#areas",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#areas",
    "title": "Calculus with Parametric Curves",
    "section": "Areas",
    "text": "Areas"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#other-resources",
    "href": "C0calculusII/home_calculusII.html#other-resources",
    "title": "Calculus II",
    "section": "Other Resources",
    "text": "Other Resources\n\nPython related\n\nCalculus I in python\nCalculus II in python\nSympy tutorial ## Teaching Assistants\n\nIn case of queries regarding attendance, quizzes, and assignments contact:\nMs. Iqra Anjum\nEmail: ges2319@giki.edu.pk"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html#integration",
    "href": "C0QuickReference/sympy/01sympybasic.html#integration",
    "title": "Sympy Basics (almost)",
    "section": "Integration",
    "text": "Integration\n\nIndefinite\n\n\nDefinite"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html#differential-equations",
    "href": "C0QuickReference/sympy/01sympybasic.html#differential-equations",
    "title": "Sympy Basics (almost)",
    "section": "Differential Equations",
    "text": "Differential Equations"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#section",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#section",
    "title": "Calculus with Parametric Curves",
    "section": "",
    "text": "Some plotting routines. Click to expand\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom sympy import plot_parametric, symbols\nfrom IPython.display import display, Markdown\nfrom functools import partial\n\n## This is a 'partial function' so that we don't have to set figure size and aspect ratio every time.\nsplot = partial(plot_parametric, aspect_ratio = (1,1),size=(4,4),axis_center = (0,0))\n\n\n\ndef _plotter(x, y, create = False):\n    if create: plt.figure(figsize=(6, 6))\n    plt.plot(x, y)\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    return\n\ndef _centeraxes():\n    ax = plt.gca()\n    # Move left y-axis and bottom x-axis to centre, passing through (0,0)\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n\n    # Eliminate upper and right axes\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n\n    # Show ticks in the left and lower axes only\n    ax.xaxis.set_ticks_position('bottom')\n    ax.yaxis.set_ticks_position('left')\n    return\n\ndef _displayM(text, expr):\n  \"\"\"\n  Display text and expression inline. \n  \"\"\"\n  display(Markdown('{} {}'.format(\n            text,\n            sp.latex(expr, mode='inline')\n          ))\n  )"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#tangents-to-parametric-curves",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#tangents-to-parametric-curves",
    "title": "Calculus with Parametric Curves",
    "section": "Tangents to Parametric Curves",
    "text": "Tangents to Parametric Curves\nSteps:\n\nFor curve \\(C = (x(t), y(t))\\), find \\(\\frac{dy}{dt}\\) and \\(\\frac{dx}{dt}\\).\nFind \\(\\frac{dy}{dx}\\)\n\n\nExample 1 (First derivative):\nFind the tangent to the line \\(x = sec(t), y = tan(t)\\) at \\((\\sqrt(2),1)\\) where \\(t=\\pi/4\\).\n\nt = symbols('t')\n\nf = sp.sec(t)\ng = sp.tan(t)\n\nsplot((f, g), (t, -sp.pi/3, sp.pi/3))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x15498a315490&gt;\n\n\nNow we need to find the slope:\n\nevalat = sp.pi/4\n\ndy_dx = sp.diff(g)/sp.diff(f)\nslope = dy_dx.subs(t, evalat)\n\ndisplay(dy_dx)\ndisplay(slope)\n\n\\(\\displaystyle \\frac{\\tan^{2}{\\left(t \\right)} + 1}{\\tan{\\left(t \\right)} \\sec{\\left(t \\right)}}\\)\n\n\n\\(\\displaystyle \\sqrt{2}\\)\n\n\nSo our tangent is a line passing through \\((\\sqrt{2},1)\\) with slope {python} slope. Let’s plot the curve and this tangent line together.\n\n# From question\nx0, y0 = sp.sqrt(2), 1\n\n## Parametric representation of a line\nx   = t\ny_t = slope * (t - x0) + y0\n\n## Plot both the curve and the tangent.\nsplot((f, g,    (t, -sp.pi/3, sp.pi/3)), \n      (t, y_t,  (t, 0, 2)),\n      )\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x1549b90ecaf0&gt;\n\n\n\n\nExample 2 (Second derivatives):\nFind \\(\\frac{d^{2}y}{dx^{2}}\\) as a function of \\(t\\) if: \\[\nx = t − t^2;\\quad y = t − t^3\n\\]\n\n## Paramterizations\nt = symbols('t')\nf = t - t**2\ng = t - t**3\n\n## Plot curve\nsplot((f, g), (t, -1, 1.5))\n\n## Find first and second derivates to curve\ndy_dx = sp.diff(g)/sp.diff(f)\nd2y_dx = sp.simplify(sp.diff(dy_dx)/sp.diff(f))\n\n## Display resulting equations\n_displayM('First derivative:', dy_dx)\n_displayM('Second derivative:', d2y_dx)\n\n\n\n\nFirst derivative: \\(\\frac{1 - 3 t^{2}}{1 - 2 t}\\)\n\n\nSecond derivative: \\(\\frac{2 \\left(3 t^{2} - 3 t \\left(2 t - 1\\right) - 1\\right)}{\\left(2 t - 1\\right)^{3}}\\)\n\n\nNow we need to find the slope:\n\nevalat = -0.75\n\nx0 = f.subs(t, evalat)\ny0 = g.subs(t, evalat)\n\nslope = dy_dx.subs(t, evalat)\n\n_displayM(f\"Slope at t = {evalat} is:\", slope)\n\nSlope at t = -0.75 is: \\(-0.275\\)\n\n\nLet’s replot the curve with the tangent.\n\nx   = t\ny_t = slope * (t - x0) + y0\n\n## Plot both the curve and the tangent.\nsplot((f, g,    (t, -sp.pi/3, sp.pi/3)), \n      (t, y_t,  (t, evalat - 1, evalat + 1)),\n      )\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x154983fbca30&gt;"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#areas-of-parametric-cruves",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#areas-of-parametric-cruves",
    "title": "Calculus with Parametric Curves",
    "section": "Areas of Parametric Cruves",
    "text": "Areas of Parametric Cruves\n\nExample 3 (Area of astroid)\n\n## Paramterizations\nt = symbols('t')\nf = sp.cos(t)**3\ng = sp.sin(t)**3\n\n## Plot curve\nsplot((f, g), (t, 0, 2* sp.pi))\n\n## Find first and second derivates to curve\ndy_dx = sp.diff(g)/sp.diff(f)\nd2y_dx = sp.simplify(sp.diff(dy_dx)/sp.diff(f))\n\n## Display resulting equations\n_displayM('First derivative:', dy_dx)\n_displayM('Second derivative:', d2y_dx)\n\n\n\n\nFirst derivative: \\(- \\sin{\\left(t \\right)} / \\cos{\\left(t \\right)}\\)\n\n\nSecond derivative: \\(\\frac{1}{3 \\sin{\\left(t \\right)} \\cos^{4}{\\left(t \\right)}}\\)\n\n\nTo find the area we make use of the symmetry of the object. We integrate \\(y\\) from \\(x=[0,1]\\) and multiply it by 4:\n\ndx = sp.diff(f, t)\ny = g\n_displayM(\"Integrand:\", y*dx)\n\nsp.integrate(4*y*dx, (t, sp.pi/2, 0))\n\nIntegrand: \\(- 3 \\sin^{4}{\\left(t \\right)} \\cos^{2}{\\left(t \\right)}\\)\n\n\n\\(\\displaystyle \\frac{3 \\pi}{8}\\)"
  },
  {
    "objectID": "C0calculusII/lectures/10_2ParametricCalculus.html#length-of-parametric-curves",
    "href": "C0calculusII/lectures/10_2ParametricCalculus.html#length-of-parametric-curves",
    "title": "Calculus with Parametric Curves",
    "section": "Length of Parametric Curves",
    "text": "Length of Parametric Curves\n\nmarker = {\"color\": \"r\", \"marker\": \"s\", \"fillstyle\":'full',\"markerfacecolor\":'white', \"markersize\":3, \"linestyle\":'--'}\n\n\nt = sp.symbols('t')\nf = t**2\ng = sp.cos(50* t)\n\n# Evaluate functions at ten points \nnumpoints = 10\ntval = [i/numpoints for i in list(range(0,numpoints))] + [1]\nfvals = [f.subs(t, t0 ) for t0 in tval]\ngvals = [g.subs(t, t0 ) for t0 in tval]\nmarker[\"args\"] = [fvals,gvals]\n\n# Plot parameters\nsp.plot_parametric(f,g, (t, 0, 1), markers = marker)\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x154983b01f70&gt;\n\n\n\\[\nL = \\int_a^b\\sqrt{f'(t)^2 + g'(t)^2} dt\n\\]\nTo make things convenient we will convert our operations into a function.\n\ndef _curvelength(f, g, var):\n  \"\"\"\n  Inputs:\n    f, g: x and y parametrizations\n    var (tuple): (sp.symbol, lower lim, upper lim)\n\n    var is a  the variable upon which to integrate.\n  \"\"\"\n  t, a, b = var\n\n  dx_dt = sp.diff(f, t)\n  dy_dt = sp.diff(g, t)\n\n  integ = (dx_dt**2 + dy_dt**2)\n  integ = sp.sqrt(integ)\n  _displayM(\"Integrating: \", integ)\n  _displayM(f\"over [{a}, {b}] w.r.t.\", t)\n\n  res = sp.integrate(integ, (t, a, b))\n  print(\"gives:\")\n\n  return res\n\n\nExample (circle/spiral)\n\nt, r = sp.symbols('t r', positive = True)\n\nf = r * sp.cos(t)\ng = r * sp.sin(t)\n\n_curvelength(f,g, (t, 0, 2 * sp.pi))\n\nIntegrating: \\(\\sqrt{r^{2} \\sin^{2}{\\left(t \\right)} + r^{2} \\cos^{2}{\\left(t \\right)}}\\)\n\n\nover [0, 2*pi] w.r.t. \\(t\\)\n\n\ngives:\n\n\n\\(\\displaystyle 2 \\pi r\\)\n\n\n\n\nExample (astroid)\n\nt = sp.symbols('t')\n\nf = (sp.cos(t))**3\ng = (sp.sin(t))**3\n\n\n_curvelength(f,g, (t, 0, sp.pi/2))\n\nIntegrating: \\(\\sqrt{9 \\sin^{4}{\\left(t \\right)} \\cos^{2}{\\left(t \\right)} + 9 \\sin^{2}{\\left(t \\right)} \\cos^{4}{\\left(t \\right)}}\\)\n\n\nover [0, pi/2] w.r.t. \\(t\\)\n\n\ngives:\n\n\n\\(\\displaystyle \\frac{3}{2}\\)\n\n\n\n\nExample (ellipse)\n\nt, a, b = sp.symbols('t a b', positive=True)\n\nf = a * sp.cos(t)\ng = b * sp.sin(t)\n\n_curvelength(f, g, (t, 0, sp.pi/2))\n\nIntegrating: \\(\\sqrt{a^{2} \\sin^{2}{\\left(t \\right)} + b^{2} \\cos^{2}{\\left(t \\right)}}\\)\n\n\nover [0, pi/2] w.r.t. \\(t\\)\n\n\ngives:\n\n\n\\(\\displaystyle \\int\\limits_{0}^{\\frac{\\pi}{2}} \\sqrt{a^{2} \\sin^{2}{\\left(t \\right)} + b^{2} \\cos^{2}{\\left(t \\right)}}\\, dt\\)\n\n\nThis is a special integral called the complete elliptic integral of the second kind.\n\n\n\n\n\n\nElliptic Integrals\n\n\n\n\n\nElliptic integrals\n\n\n\nLet’s take the parametrization again and look for a series solution.\n\ndx_dt = sp.diff(f,t)\ndy_dt = sp.diff(g,t)\n\necc = sp.symbols('e')\n# e = sp.sqrt(1 - (b/a)**2)\n\n\n\nintegrand = (dx_dt**2 + dy_dt**2)\nintegrand = integrand.subs({a: b/sp.sqrt(1-ecc**2),\n                            sp.cos(t)**2: 1 - sp.sin(t**2)})\nintegrand\n\n\\(\\displaystyle b^{2} \\left(1 - \\sin{\\left(t^{2} \\right)}\\right) + \\frac{b^{2} \\sin^{2}{\\left(t \\right)}}{1 - e^{2}}\\)\n\n\n\nt, e = sp.symbols('t e')\nf = sp.sqrt(1 - e**2 * sp.sin(t**2))\nsp.series(f,t)\n\n\\(\\displaystyle 1 - \\frac{e^{2} t^{2}}{2} - \\frac{e^{4} t^{4}}{8} + O\\left(t^{6}\\right)\\)"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html",
    "href": "C0QuickReference/sympy/01sympybasic.html",
    "title": "Sympy Basics (almost)",
    "section": "",
    "text": "import sympy as sp"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html#differentiation",
    "href": "C0QuickReference/sympy/01sympybasic.html#differentiation",
    "title": "Sympy Basics (almost)",
    "section": "Differentiation",
    "text": "Differentiation"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html#expressions",
    "href": "C0QuickReference/sympy/01sympybasic.html#expressions",
    "title": "Sympy Basics (almost)",
    "section": "Expressions",
    "text": "Expressions\n\n\nSubstitutions\nfrom sympy import symbols, sin, cos\n\n# Define symbols\nx, y = symbols('x y')\n\n# Define the original expression\nexpr = sin(2*x) + cos(2*x)\n\n# Define the substitution for x\nsubstitution = {x: y + 2}\n\n# Apply the substitution\nexpr_substituted = expr.subs(substitution)\n\n# Print the result\nprint(expr_substituted)\n\n\nsin(2*y + 4) + cos(2*y + 4)\n\n\n\n\nCheck if two expressions are the same\nx = symbols('x')\n\nexpr1 = 9/8 - 9 * sp.cos(4*x)/8\nexpr2 = 9 * sp.sin(x)**2 * sp.cos(x)**2\n\nexpr1.equals(expr2)\n\n\nTrue"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#quizzes",
    "href": "C0calculusII/home_calculusII.html#quizzes",
    "title": "Calculus II",
    "section": "Quizzes",
    "text": "Quizzes\nWe will most likely have three quizzes:\n\nQuiz 1 [5 Marks]\nQuiz 2 (10 marks, 8th week)\nQuiz 3 (10 marks, 13th week)\n\n\nDecember 10 (Tuesday), 6:00pm at LH4, FES \nFrom chapters 13 & 14"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#assignments",
    "href": "C0calculusII/home_calculusII.html#assignments",
    "title": "Calculus II",
    "section": "Assignments",
    "text": "Assignments\nAssignment 1\nAssignment 2\nAssignment 3\nAssignment 4\nAssignment 5"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#quizzes",
    "href": "C0calculusI/home_calculusI.html#quizzes",
    "title": "Calculus I",
    "section": "Quizzes",
    "text": "Quizzes\nWe will most likely have three quizzes. Tentatively:\n\nQuiz 1 [5 Marks]\nQuiz 2 (10 marks, 8th week)\nQuiz 3 (10 marks, 13th week)\n\n\nDecember 10 (Tuesday), 6:00pm at LH4, FES \n4.3 to 4.5, 5.1 to 5.6 (as studied in class), 6.1, 6.2\n\n\nN.B.: If you can’t take the quiz for some reason, you need to inform us in advance."
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#assignments",
    "href": "C0calculusI/home_calculusI.html#assignments",
    "title": "Calculus I",
    "section": "Assignments",
    "text": "Assignments\nAssignment 1\nAssignment 2\nAssignment 3\nAssignment 4\nAssignment 5"
  },
  {
    "objectID": "C0calculusII/notebooks/test.html",
    "href": "C0calculusII/notebooks/test.html",
    "title": "Plots Demo",
    "section": "",
    "text": "using Plots\n\n# Sample data\nx = 1:10\ny = rand(10)  # Random y values\n\n# Create a plot\nplot(x, y, \n     title=\"Simple Plot\", \n     xlabel=\"X-axis\", \n     ylabel=\"Y-axis\", \n     label=\"Random Data\", \n     legend=:topright)"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "",
    "text": "Some plotting routines. Click to expand\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom sympy import plot_parametric, symbols\nfrom IPython.display import display, Markdown\nfrom functools import partial\n\n## This is a 'partial function' so that we don't have to set figure size and aspect ratio every time.\nsplot = partial(plot_parametric, aspect_ratio = (1,1),size=(4,4),axis_center = (0,0))\n\n\ndef _displayM(text, expr):\n  \"\"\"\n  Display text and expression inline. \n  \"\"\"\n  display(Markdown('{} {}'.format(\n            text,\n            sp.latex(expr, mode='inline')\n          ))\n  )"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html#example-r-1---cost",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html#example-r-1---cost",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "Example (r = 1 - cos(t))",
    "text": "Example (r = 1 - cos(t))\n\n# x, y = sp.symbols('x y')\nr, t = sp.symbols('r t')\n\nr = 1 - sp.cos(t)\n\nx = r * sp.cos(t)\ny = r * sp.sin(t)\nsplot((x,y), (t, 0, 2 * sp.pi))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x149f1aa20880&gt;"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html#example-r2-4-cost",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html#example-r2-4-cost",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "Example ($r^2 = 4 cos(t))",
    "text": "Example ($r^2 = 4 cos(t))\n\n## NUMPY\n## -----\n# Define the parameter\nt = np.linspace(0, 2 * np.pi, 1000)\n\n# Compute r from the parametrization\nr = np.sqrt(4* np.cos(t))\n\n# Compute x and y for the two lobes\nx1 = r * np.cos(t)\ny1 = r * np.sin(t)\n\nx2 = -r * np.cos(t)\ny2 = -r * np.sin(t)\n\n# Plot using Matplotlib\nplt.figure(figsize=(6, 6))\nplt.plot(x1, y1)\nplt.plot(x2, y2)\n\nplt.axhline(0, color='black',linewidth=0.5)\nplt.axvline(0, color='black',linewidth=0.5)\nplt.grid(True, which='both')\nplt.gca().set_aspect('equal', adjustable='box')\nplt.show()\n\n/tmp/ipykernel_278858/4250302634.py:7: RuntimeWarning: invalid value encountered in sqrt\n  r = np.sqrt(4* np.cos(t))\n\n\n\n\n\n\n## SYMPY\n##-------\nr, t = sp.symbols('r t', positive = False)\n\nr_sq = 4 * sp.cos(t)\nr_lobes = [sp.sqrt(r_sq), -sp.sqrt(r_sq)]\n\n## Find x and y\nx_lobes = [lobe * sp.cos(t) for lobe in r_lobes]\ny_lobes = [lobe * sp.sin(t) for lobe in r_lobes]\n\nsplot((x_lobes[0],y_lobes[0], (t, - sp.pi/2, sp.pi/2)),\n      (x_lobes[1],y_lobes[1], (t, - sp.pi/2, sp.pi/2))\n)\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x149f1ab64f10&gt;"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html#lengths-in-polar-coordinates",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html#lengths-in-polar-coordinates",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "Lengths in Polar Coordinates",
    "text": "Lengths in Polar Coordinates\n\nLength of cardioid (\\(r= 1 - cos(\\theta)\\))\n\n# Total area\n\nfrom sympy.simplify.fu import TR11, TR0\n\n\nr, t = sp.symbols('r t', real = True)\n\nr = (1 - sp.cos(t))\ndrdt = sp.diff(r,t)\n\n\nf = sp.sqrt(r**2 + drdt**2)\nintegrand = sp.simplify(f)\n# integrand = integrand.subs(sp.sqrt(1-sp.cos(t)), sp.sin(t/2)*2)\nintegrand\n# sp.integrate(integrand, (t, 0, 2 * sp.pi))\n\n\\(\\displaystyle \\sqrt{2 - 2 \\cos{\\left(t \\right)}}\\)\n\n\n\nfrom sympy.simplify.fu import TR11, TR0\nfrom sympy import cos, sin, pi\nfrom sympy.abc import x\nTR0(TR11(integrand, base = t*2))\n\n\\(\\displaystyle \\sqrt{2} \\sqrt{1 - \\cos{\\left(t \\right)}}\\)"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html#areas-in-polar-coordinates",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html#areas-in-polar-coordinates",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "Areas in Polar Coordinates",
    "text": "Areas in Polar Coordinates\n\nOf cardioid (\\(r = 2(1+cos(\\theta))\\))\n\n# Total area\n\nr, t = sp.symbols('r t')\n\nr = 2 * (1 + sp.cos(t))\n\nsp.integrate(1/2 * r**2, (t, 0, 2 * sp.pi))\n\n\\(\\displaystyle 6.0 \\pi\\)\n\n\n\n\nArea between curves\n\n# Area between regions \n\n##-- Define curves\nr1, r2, t = sp.symbols('r1 r2 t')\n\nr1 = 1 - sp.cos(t)\nr2 = 1\n\n##-- Find Area\n\nres = sp.integrate((r2**2 - r1**2)/2, (t, -sp.pi/2, sp.pi/2))\n_displayM(\"Area between curves is:\", res)\n\n\n##-- Plot curves\nx1 = r1 * sp.cos(t)\ny1 = r1 * sp.sin(t)\n\nx2 = r2 * sp.cos(t)\ny2 = r2 * sp.sin(t)\n\nsplot((x1,y1, (t, -sp.pi/2, sp.pi/2)),\n      (x2,y2, (t, -sp.pi/2, sp.pi/2))\n)\n\nArea between curves is: \\(2 - \\pi / 4\\)\n\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x149f186f7880&gt;"
  },
  {
    "objectID": "C0calculusII/notebooks/juliatest.html",
    "href": "C0calculusII/notebooks/juliatest.html",
    "title": "Plots Demo",
    "section": "",
    "text": "using Plots\n\n# Sample data\nx = 1:10\ny = rand(10)  # Random y values\n\n# Create a plot\nplot(x, y, \n     title=\"Simple Plot\", \n     xlabel=\"X-axis\", \n     ylabel=\"Y-axis\", \n     label=\"Random Data\", \n     legend=:topright)"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#temp",
    "href": "C0calculusII/home_calculusII.html#temp",
    "title": "Calculus II",
    "section": "Temp",
    "text": "Temp\n\nJulia test"
  },
  {
    "objectID": "C0calculusII/lectures/10_3ParametricPolar.html#intersecting-curves",
    "href": "C0calculusII/lectures/10_3ParametricPolar.html#intersecting-curves",
    "title": "Parametric Curves and Polar Coordinates",
    "section": "Intersecting curves",
    "text": "Intersecting curves\n\nr1, r2, t = sp.symbols('r1 r2 t')\n\nr1 = 2 * sp.cos(t/3)\nr2 = sp.sqrt(2)\n\n## Find intersects to r1 == r2.\nres = sp.solve(r1 - r2, t, dict = True)\n\nres\n## Display neatly\n# [_displayM(f\"Solution {idx}: \", i[t]) for idx, i in enumerate(res)];\n\n[{t: 3*pi/4}, {t: 21*pi/4}]\n\n\n\nx = [r * sp.cos(t) for r in (r1, r2)]\ny = [r * sp.sin(t) for r in (r1, r2)]\n\nsplot(x[1], y[1], (t, 0, 2 * sp.pi))\n\nsplot((x[1], y[1], (t, 0, 2 * sp.pi)),\n(x[0], y[0], (t, 0, 4 * sp.pi))\n\n)\n\n\n\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x149f180b4b80&gt;"
  },
  {
    "objectID": "C0QuickReference/sympy/01sympybasic.html#plotting",
    "href": "C0QuickReference/sympy/01sympybasic.html#plotting",
    "title": "Sympy Basics (almost)",
    "section": "Plotting",
    "text": "Plotting\n\nFill color\n\nimport sympy as sy\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = sy.symbols('x')\nf = sy.sin(x)\n\nx_array = np.linspace(0, np.pi, 1000)\nf_array = sy.lambdify(x, f)(x_array)\n\nfig, ax = plt.subplots()\n\nax.plot(x_array, f_array, color = 'red')\nax.fill_between(x_array, f_array, facecolor = 'red', alpha = 0.3)\n\nplt.show()"
  },
  {
    "objectID": "C0calculusI/lectures/2limitscontinuity.html",
    "href": "C0calculusI/lectures/2limitscontinuity.html",
    "title": "Limits and Continuity",
    "section": "",
    "text": "import pandas as pd\nimport sympy as sp\n\nmarker = {\"color\": \"r\", \"marker\": \"s\", \"fillstyle\":'full',\"markerfacecolor\":'white', \"markersize\":10, \"linestyle\":'--'}"
  },
  {
    "objectID": "C0calculusI/lectures/2limitscontinuity.html#averages",
    "href": "C0calculusI/lectures/2limitscontinuity.html#averages",
    "title": "Limits and Continuity",
    "section": "Averages",
    "text": "Averages\n\nx = sp.symbols('x')\n\ny = 4.9 * x**2\n\nevalat = [1,2,3,4,5]\nresult = [y.subs(x, i).evalf(3) for i in evalat]\n\nxypairs = list(zip(evalat, result))\n\npd.DataFrame(xypairs, columns = ['x', 'y'])\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n1\n4.90\n\n\n1\n2\n19.6\n\n\n2\n3\n44.1\n\n\n3\n4\n78.4\n\n\n4\n5\n123.\n\n\n\n\n\n\n\n\nx = sp.symbols('x')\nfunc = 4.9 * x**2\n\nevalat = [1, 3, 7]\ny = [func.subs(x, val) for val in evalat]\n\nmarker['args'] = [evalat, y] #See presets at top\n\nsp.plot(func, (x,-1,7), \nmarkers = marker, \nannotations=[{'xy': (3, 120), 'text': \"Secant\", 'fontsize':15}]\n)\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14a56deef0a0&gt;\n\n\nWe can also evaluate this numerically:"
  },
  {
    "objectID": "C0calculusI/lectures/2limitscontinuity.html#limits",
    "href": "C0calculusI/lectures/2limitscontinuity.html#limits",
    "title": "Limits and Continuity",
    "section": "Limits",
    "text": "Limits\n\nOf rational functions\n\n# Limits of rational functions\n\nx = sp.symbols('x')\np = x**3 + 4*x**2 - 3\nq = x**2 + 5\n\nrp = p/q\n\nevalat = -1\nresult = sp.limit(rp, x, evalat)\n\n# sp.plot(rp, (x, -2,0))\nmarker['args'] = [evalat, result]\n\nsp.plot(rp, (x, -2,0), markers = marker)\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14a52e4ef8b0&gt;\n\n\n\n\nExample - Limit with denominator 0\n\nimport sympy as sp\nx = sp.symbols('x')\n\nf = (sp.sqrt(x**2 + 100) - 10)/ x**2\n\nsp.plot(f, (x, -1 , 1))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14a53ae4f4c0&gt;\n\n\n\n\nSandwich theorem\n\nimport sympy as sp\nx = sp.symbols('x')\n\nxi, xf = -1,1\n\nf = x**2 * sp.sin(1/x**2)\nupper = x**2\nlower = -x**2\n\nsp.plot(f, (x, xi , xf))\n\nsp.plot((f, (x, xi , xf)),\n        (upper, (x,xi, xf)),\n        (lower, (x, xi, xf))\n)\n\n\n\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14a52ef842e0&gt;\n\n\n\n\nOne-sided limits\n\n\nLimits (Rigorous definition)\n\n\nLimits involving infinity\n\nOblique asymptotes\n\nx = sp.symbols('x')\nf = (x**3 - 8)/(x-4) \n\nsp.limit(f,x, 0)\n\nsp.plot(f, (x,3.99,4.01))\n\n\n\n\n&lt;sympy.plotting.backends.matplotlibbackend.matplotlib.MatplotlibBackend at 0x14a52ee63bb0&gt;"
  },
  {
    "objectID": "C0history/1_conics.html",
    "href": "C0history/1_conics.html",
    "title": "Conics (A History)",
    "section": "",
    "text": "Conic sections, the curves obtained by slicing a cone at various angles, have a long and rich history in mathematics, dating back to Ancient Greece. These curves include ellipses, parabolas, and hyperbolas, and have been studied for over 2,000 years due to their theoretical beauty and practical applications. Here’s an overview of their historical development and key applications:"
  },
  {
    "objectID": "C0history/1_conics.html#ancient-greece-circa-4th-century-bce",
    "href": "C0history/1_conics.html#ancient-greece-circa-4th-century-bce",
    "title": "Conics (A History)",
    "section": "1 Ancient Greece (circa 4th century BCE)",
    "text": "1 Ancient Greece (circa 4th century BCE)\nThe first known study of conic sections was by Menaechmus, a student of Plato in the 4th century BCE. He discovered the curves while investigating solutions to geometric problems, specifically the famous Delian problem (doubling the cube). His work established the basic forms of the conic sections, showing that by cutting a cone with a plane at different angles, one could derive different curves:\nEllipse (cutting the cone at an angle less than the slope of the cone).\nParabola (cutting parallel to the cone’s slope).\nHyperbola (cutting steeper than the cone’s slope)."
  },
  {
    "objectID": "C0history/1_conics.html#apollonius-of-perga-circa-262190-bce",
    "href": "C0history/1_conics.html#apollonius-of-perga-circa-262190-bce",
    "title": "Conics (A History)",
    "section": "2 Apollonius of Perga (circa 262–190 BCE)",
    "text": "2 Apollonius of Perga (circa 262–190 BCE)\nOne of the most influential figures in the study of conic sections was Apollonius of Perga, who is often referred to as the “Great Geometer.” His treatise, Conics, is a comprehensive text that systematically explored these curves. Apollonius is credited with giving the conic sections their modern names and rigorously analyzing their properties. He studied the intersections, tangents, and focus-directrix properties of these curves. His work laid the foundation for much of the later study in mathematics and astronomy."
  },
  {
    "objectID": "C0history/1_conics.html#archimedes-circa-287212-bce",
    "href": "C0history/1_conics.html#archimedes-circa-287212-bce",
    "title": "Conics (A History)",
    "section": "3 Archimedes (circa 287–212 BCE)",
    "text": "3 Archimedes (circa 287–212 BCE)\nArchimedes applied conic sections in various practical and theoretical contexts. He used parabolas in his work on quadrature (the problem of determining the area under a curve) and explored their use in physics. Archimedes calculated the area enclosed by a parabola using geometric methods, a precursor to integral calculus."
  },
  {
    "objectID": "C0history/1_conics.html#middle-ages-and-the-islamic-golden-age",
    "href": "C0history/1_conics.html#middle-ages-and-the-islamic-golden-age",
    "title": "Conics (A History)",
    "section": "4 Middle Ages and the Islamic Golden Age",
    "text": "4 Middle Ages and the Islamic Golden Age\nDuring the Islamic Golden Age (circa 8th–14th centuries), scholars such as Ibn al-Haytham (Alhazen) and Omar Khayyam built on the work of the Greeks. Alhazen explored the optics of lenses and mirrors using conic sections, especially parabolas, which are important in the study of light reflection. Khayyam extended the study of conic sections to solve algebraic problems, such as cubic equations."
  },
  {
    "objectID": "C0history/1_conics.html#renaissance-and-early-modern-period",
    "href": "C0history/1_conics.html#renaissance-and-early-modern-period",
    "title": "Conics (A History)",
    "section": "5 Renaissance and Early Modern Period",
    "text": "5 Renaissance and Early Modern Period\nConic sections gained new attention during the Renaissance, when European scholars rediscovered and translated ancient Greek and Arabic works. Johannes Kepler (1571–1630) used conic sections in his laws of planetary motion, revolutionizing astronomy. He demonstrated that planetary orbits are ellipses, with the Sun at one of the foci. Kepler’s laws formed a cornerstone of Newton’s theory of gravitation.\nRené Descartes (1596–1650) and Pierre de Fermat (1601–1665) furthered the study of conic sections by developing the early forms of analytic geometry, allowing these curves to be described using algebraic equations. This shifted the study of geometry into a more algebraic framework, simplifying the representation and manipulation of conic sections."
  },
  {
    "objectID": "C0history/1_conics.html#isaac-newton-16421727",
    "href": "C0history/1_conics.html#isaac-newton-16421727",
    "title": "Conics (A History)",
    "section": "6 Isaac Newton (1642–1727)",
    "text": "6 Isaac Newton (1642–1727)\nIsaac Newton used conic sections in his work on gravitation and mechanics. In his Philosophiæ Naturalis Principia Mathematica, Newton derived the trajectories of objects under gravity and demonstrated that these paths could be parabolas, hyperbolas, or ellipses, depending on the object’s velocity and distance from the Sun."
  },
  {
    "objectID": "C0history/1_conics.html#modern-applications",
    "href": "C0history/1_conics.html#modern-applications",
    "title": "Conics (A History)",
    "section": "7 Modern Applications",
    "text": "7 Modern Applications\nConic sections continue to be of critical importance in various fields today:\nAstronomy: The orbits of planets, comets, and other celestial bodies are elliptical (Kepler’s laws).\nPhysics: Parabolic reflectors and antennas, such as those used in telescopes and satellite dishes, are shaped by the properties of parabolas to focus signals and light.\nEngineering: Hyperbolas are used in navigation systems, such as LORAN and GPS, to determine location based on the difference in distances to multiple fixed points.\nArchitecture: The curves are used in the design of arches, bridges, and buildings to distribute loads efficiently.\nConic sections are an enduring element of geometry and mathematics, and their utility spans centuries, from classical problems to modern technology."
  },
  {
    "objectID": "C0calculusII/lectures/10_5ConicSections.html",
    "href": "C0calculusII/lectures/10_5ConicSections.html",
    "title": "Conic Sections",
    "section": "",
    "text": "Some plotting routines. Click to expand\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom sympy import plot_parametric, symbols\nfrom IPython.display import display, Markdown\nfrom functools import partial\n\n## This is a 'partial function' so that we don't have to set figure size and aspect ratio every time.\nsplot = partial(plot_parametric, aspect_ratio = (1,1),size=(4,4),axis_center = (0,0))\n\n\n\ndef _plotter(x, y, create = False):\n    if create: plt.figure(figsize=(6, 6))\n    plt.plot(x, y)\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    return\n\ndef _centeraxes():\n    ax = plt.gca()\n    # Move left y-axis and bottom x-axis to centre, passing through (0,0)\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n\n    # Eliminate upper and right axes\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n\n    # Show ticks in the left and lower axes only\n    ax.xaxis.set_ticks_position('bottom')\n    ax.yaxis.set_ticks_position('left')\n    return\n\ndef _displayM(text, expr):\n  \"\"\"\n  Display text and expression inline. \n  \"\"\"\n  display(Markdown('{} {}'.format(\n            text,\n            sp.latex(expr, mode='inline')\n          ))\n  )"
  },
  {
    "objectID": "C0calculusII/lectures/10_5ConicSections.html#section",
    "href": "C0calculusII/lectures/10_5ConicSections.html#section",
    "title": "Conic Sections",
    "section": "",
    "text": "Some plotting routines. Click to expand\nimport numpy as np\nimport sympy as sp\nimport matplotlib.pyplot as plt\nfrom sympy import plot_parametric, symbols\nfrom IPython.display import display, Markdown\nfrom functools import partial\n\n## This is a 'partial function' so that we don't have to set figure size and aspect ratio every time.\nsplot = partial(plot_parametric, aspect_ratio = (1,1),size=(4,4),axis_center = (0,0))\n\n\n\ndef _plotter(x, y, create = False):\n    if create: plt.figure(figsize=(6, 6))\n    plt.plot(x, y)\n    plt.gca().set_aspect('equal', adjustable='box')\n\n    return\n\ndef _centeraxes():\n    ax = plt.gca()\n    # Move left y-axis and bottom x-axis to centre, passing through (0,0)\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n\n    # Eliminate upper and right axes\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')\n\n    # Show ticks in the left and lower axes only\n    ax.xaxis.set_ticks_position('bottom')\n    ax.yaxis.set_ticks_position('left')\n    return\n\ndef _displayM(text, expr):\n  \"\"\"\n  Display text and expression inline. \n  \"\"\"\n  display(Markdown('{} {}'.format(\n            text,\n            sp.latex(expr, mode='inline')\n          ))\n  )"
  },
  {
    "objectID": "C0calculusII/lectures/10_5ConicSections.html#parabola",
    "href": "C0calculusII/lectures/10_5ConicSections.html#parabola",
    "title": "Conic Sections",
    "section": "Parabola",
    "text": "Parabola\n\n%matplotlib inline\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef conic(x, tp = 'parabola', p = {}):\n  \"\"\"\n  x = values at which to compute\n  tp = type of conic\n  p = parameters\n  \"\"\"\n  if tp == 'parabola': \n    y = p['a'] * (x - p['h'])**2 + p['k']\n    focus = {'x': p['h'], \n              'y': p['k'] + 1/(4 * p['a'])}\n\n  if tp == 'circle':\n    circle_x = p['c_x'] + p['r'] * np.cos(x)\n    circle_y = p['c_y'] + p['r'] * np.sin(x)\n\n    return circle_x, circle_y\n\n\n  return y, focus\n\n## Generate parabola\nx = np.linspace(-2, 2, 400)\nparams = {'a': 1, 'h': 0, 'k': 0}\ny, focus = conic(x, 'parabola', p = params)\n\n## Point of observation\nind = 300\npb_x, pb_y = np.abs(x[ind]), np.abs(y[ind])\n\n# Plot\nplt.figure(figsize=(8, 8))\nplt.plot(x, y, label='$y = x^2$', color='blue')\nplt.scatter(focus['x'], focus['y'], color='green', zorder=5, s=100)\nplt.text(focus['x'] + 0.1, focus['y'], 'F')\n\nplt.text(focus['x'] -1.95, -focus['y']-0.13, 'Directrix', fontsize= 15)\n\nplt.scatter(pb_x, pb_y, color='green', zorder = 3, s = 100)\n\n## Plot settings\nplt.xlim(-2, 2)\nplt.ylim(-2, 2)\nplt.grid(True)\nplt.axhline(-focus['y'], color='red', linewidth=2, ls = '--')\nplt.axhline(0, color='black', linewidth=1)\nplt.axvline(0, color='black', linewidth=1)\n\n#__________________________________________\n\n#==================================\n### DO NOT DELETE (Uncomment to show circles)\n#==================================\n\n# ##=============== Circles \n# radius = np.sqrt((focus['x'] - pb_x)**2 + (focus['y'] - pb_y)**2)\n\n# theta = np.linspace(0, 2 * np.pi, 400)\n\n# ## Circle A\n# params = {'c_x': focus['x'], 'c_y': focus['y'], 'r': radius}\n# theta = np.linspace(0, 2 * np.pi, 400)\n# circle_x, circle_y = conic(theta, 'circle', p = params)\n\n# plt.plot(circle_x, circle_y, color='red')\n\n\n# ## Circle B\n# params = {'c_x': pb_x, 'c_y': -focus['y'], 'r': radius}\n# circle_2x, circle_2y = conic(theta, 'circle', p = params)\n\n# plt.plot(circle_2x, circle_2y, color='red')\n\n# ## Lines\n# plt.plot([pb_x, pb_x], [-focus['y'], pb_y], '--') #vertical dashed line\n# plt.plot([0, pb_x], [focus['y'], pb_y], '--') #line from focus to parabola \n\n#__________________________\n\n\nplt.show()\n\n\n\n\nWe can animate the circles to show how the distances from the focus to a point on the parabola, and a circle on directrix directly under the parabola are the same.\n\n\nParabola Animation\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML\n\n# Use the notebook backend for interactive plots\n%matplotlib notebook\n\n# Set up the figure and axes\nfig, ax = plt.subplots(figsize = [4,4])\nxdata, ydata = [], []\ncircleA, = plt.plot([], [], 'r-')\ncircleB, = plt.plot([], [], 'r-')\npoint,   = plt.plot([], [], 'bo', zorder = 10, markersize = 10)\n\nlinev,   = plt.plot([], [], '--') #vertical dashed line\nlinef,   = plt.plot([], [], '--') #line from focus to parabola \n\n# Initialize the plot\ndef init():\n    ax.set_xlim(0, 2 * np.pi)\n    ax.set_ylim(-1, 1)\n\n    #Create parabola, foci etc. \n    ## Generate parabola\n    x = np.linspace(-2, 2, 400)\n    params = {'a': 1, 'h': 0, 'k': 0}\n    y, focus = conic(x, 'parabola', p = params)\n\n    ## Plot Focus\n    plt.plot(x, y, label='$y = x^2$', color='blue')\n    plt.scatter(focus['x'], focus['y'], color='green', zorder=5, s=80)\n    plt.text(focus['x'] + 0.1, focus['y'], 'F')\n\n    ## Plot settings\n    plt.xlim(-2, 2)\n    plt.ylim(-2, 2)\n    plt.grid(True)\n    plt.axhline(-focus['y'], color='black', linewidth=1)\n    plt.axvline(0, color='black', linewidth=1)\n    return plt\n\n# Update function for animation\ndef update(frames):\n\n\n    ## Point of observation\n    ind = frames \n    pb_x, pb_y = np.abs(x[ind]), np.abs(y[ind])\n    point.set_data(pb_x, pb_y)\n    \n\n    ##=============== Circles \n    radius = np.sqrt((focus['x'] - pb_x)**2 + (focus['y'] - pb_y)**2)\n    theta = np.linspace(0, 2 * np.pi, 400)\n\n    ## Circle A\n    params = {'c_x': focus['x'], 'c_y': focus['y'], 'r': radius}\n    circle_x, circle_y = conic(theta, 'circle', p = params)\n   \n    circleA.set_data(circle_x, circle_y)\n\n    ## Circle B\n    params = {'c_x': pb_x, 'c_y': -focus['y'], 'r': radius}\n    circle_2x, circle_2y = conic(theta, 'circle', p = params)\n\n    circleB.set_data(circle_2x, circle_2y)\n\n    ##============== Lines\n    linev.set_data([pb_x, pb_x], [-focus['y'], pb_y])\n    linef.set_data([0, pb_x], [focus['y'], pb_y])\n\n\n    return \n\n# Create the animation\nani = FuncAnimation(\n    fig, update, frames=list(range(200)),\n    init_func=init, blit=True, interval=20\n)\n\n# Display the animation\nHTML(ani.to_html5_video())\n\n\n\n\n\n\n\n\n/tmp/ipykernel_23069/2707575446.py:50: MatplotlibDeprecationWarning:\n\nSetting data with a non sequence type is deprecated since 3.7 and will be remove two minor releases later\n\n\n\n\n  \n  Your browser does not support the video tag."
  },
  {
    "objectID": "C0calculusII/lectures/10_5ConicSections.html#ellipse",
    "href": "C0calculusII/lectures/10_5ConicSections.html#ellipse",
    "title": "Conic Sections",
    "section": "Ellipse",
    "text": "Ellipse\nWarning: The code below needs tweaking.\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Function to generate ellipse points\ndef generate_ellipse(a, e, num_points=100):\n    b = a * np.sqrt(1 - e**2)  # semi-minor axis\n    theta = np.linspace(0, 2 * np.pi, num_points)\n    x = a * np.cos(theta)\n    y = b * np.sin(theta)\n    return x, y\n\n# Initial parameters\neccentricity = 0.5\nsemi_major_axis = 1\nnum_points = 100\n\n# Create initial ellipse\nx, y = generate_ellipse(semi_major_axis, eccentricity)\n\n# Create the figure and add the initial ellipse\nfig = make_subplots(rows=1, cols=1)\nfig.add_trace(go.Scatter(x=x, y=y, mode='lines', name='Ellipse'))\n\n# Set fixed axis limits\nfig.update_layout(\n    title=f'Ellipse with Semi-Major Axis = {semi_major_axis}, Eccentricity = {eccentricity:.2f}',\n    xaxis_title='X',\n    yaxis_title='Y',\n    xaxis=dict(scaleanchor=\"y\", range=[-2, 2]),\n    yaxis=dict(constrain='domain', range=[-2, 2]),\n    showlegend=False\n)\n\n# Create sliders for eccentricity and semi-major axis\nfig.update_layout(\n    sliders=[\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Eccentricity: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.1,\n            'steps': [{\n                'label': f'{i/100:.2f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipse(semi_major_axis, i/100)[0]], \n                                'y': [generate_ellipse(semi_major_axis, i/100)[1]]},\n                          {'title': f'Ellipse with Semi-Major Axis = {semi_major_axis}, Eccentricity = {i/100:.2f}'}]\n                } for i in range(0, 101, 10)]  # Eccentricity steps\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.3,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipse(i/10, eccentricity)[0]], \n                             'y': [generate_ellipse(i/10, eccentricity)[1]]},\n                          {'title': f'Ellipse with Semi-Major Axis = {i/10:.1f}, Eccentricity = {eccentricity:.2f}'}]\n                } for i in range(1, 21)]  # Semi-major axis steps from 0.1 to 2.0\n        }\n    ]\n)\n\n# Show the figure\nfig.show()"
  },
  {
    "objectID": "C0calculusII/lectures/10_5ConicSections.html#hyperbola",
    "href": "C0calculusII/lectures/10_5ConicSections.html#hyperbola",
    "title": "Conic Sections",
    "section": "Hyperbola",
    "text": "Hyperbola"
  },
  {
    "objectID": "C0QuickReference/matplotlib/01animate.html",
    "href": "C0QuickReference/matplotlib/01animate.html",
    "title": "Animation",
    "section": "",
    "text": "Working example that works for quarto\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML\n\n# Use the notebook backend for interactive plots\n%matplotlib notebook\n\n# Set up the figure and axes\nfig, ax = plt.subplots()\nxdata, ydata = [], []\nln, = plt.plot([], [], 'r-')\n\n# Initialize the plot\ndef init():\n    ax.set_xlim(0, 2 * np.pi)\n    ax.set_ylim(-1, 1)\n    return ln,\n\n# Update function for animation\ndef update(frame):\n    xdata.append(frame)\n    ydata.append(np.sin(frame))\n    ln.set_data(xdata, ydata)\n    return ln,\n\n# Create the animation\nani = FuncAnimation(\n    fig, update, frames=np.linspace(0, 2 * np.pi, 128),\n    init_func=init, blit=True, interval=50\n)\n\n# Display the animation\nHTML(ani.to_html5_video())\n\n\n\n\n\n\n\n\n  \n  Your browser does not support the video tag."
  },
  {
    "objectID": "C0QuickReference/matplotlib/01animate.html#simple-example-funcanimation",
    "href": "C0QuickReference/matplotlib/01animate.html#simple-example-funcanimation",
    "title": "Animation",
    "section": "",
    "text": "Working example that works for quarto\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom IPython.display import HTML\n\n# Use the notebook backend for interactive plots\n%matplotlib notebook\n\n# Set up the figure and axes\nfig, ax = plt.subplots()\nxdata, ydata = [], []\nln, = plt.plot([], [], 'r-')\n\n# Initialize the plot\ndef init():\n    ax.set_xlim(0, 2 * np.pi)\n    ax.set_ylim(-1, 1)\n    return ln,\n\n# Update function for animation\ndef update(frame):\n    xdata.append(frame)\n    ydata.append(np.sin(frame))\n    ln.set_data(xdata, ydata)\n    return ln,\n\n# Create the animation\nani = FuncAnimation(\n    fig, update, frames=np.linspace(0, 2 * np.pi, 128),\n    init_func=init, blit=True, interval=50\n)\n\n# Display the animation\nHTML(ani.to_html5_video())\n\n\n\n\n\n\n\n\n  \n  Your browser does not support the video tag."
  },
  {
    "objectID": "C0history/home_history.html",
    "href": "C0history/home_history.html",
    "title": "History of Mathematics",
    "section": "",
    "text": "Caution\n\n\n\nUse of generative AI might abound in the following links. Use with caution.\n\n\nConics"
  },
  {
    "objectID": "C0QuickReference/matplotlib/01animate.html#d-plot-animation-.py",
    "href": "C0QuickReference/matplotlib/01animate.html#d-plot-animation-.py",
    "title": "Animation",
    "section": "3D Plot Animation (.py)",
    "text": "3D Plot Animation (.py)\nRun the following in a .py file.\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import axes3d\nfrom matplotlib import cm\n\n# Enable interactive mode\nplt.ion()\n\n# Create a new figure\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\n# Generate test data\nX, Y, Z = axes3d.get_test_data(0.05)\n\n# Plot surface and contours\nax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)\ncset = ax.contour(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)\n\n# Set labels and limits\nax.set_xlabel('X')\nax.set_xlim(-40, 40)\nax.set_ylabel('Y')\nax.set_ylim(-40, 40)\nax.set_zlabel('Z')\nax.set_zlim(-100, 100)\n\n# Show the plot\nplt.show()\n\n# Keep the plot open\nplt.ioff()\nplt.show()"
  },
  {
    "objectID": "C0QuickReference/matplotlib/01animate.html#d-plot-animation-.ipynb",
    "href": "C0QuickReference/matplotlib/01animate.html#d-plot-animation-.ipynb",
    "title": "Animation",
    "section": "3D Plot Animation (.ipynb)",
    "text": "3D Plot Animation (.ipynb)\nYou may have to install ipympl first. See link.\nNote that these will not be rendered below because there is no jupyter kernel in html.\n\n# Use this line at the beginning of your Jupyter notebook\n%matplotlib widget\n\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nX, Y, Z = axes3d.get_test_data(0.05)\nax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)\ncset = ax.contour(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)\n\nax.set_xlabel('X')\nax.set_xlim(-40, 40)\nax.set_ylabel('Y')\nax.set_ylim(-40, 40)\nax.set_zlabel('Z')\nax.set_zlim(-100, 100)\n\nplt.show()\n\nWarning: Cannot change to a different GUI toolkit: widget. Using notebook instead."
  },
  {
    "objectID": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html",
    "href": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html",
    "title": "Vectors and Geometry of Space",
    "section": "",
    "text": "import matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# mpl.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.add_subplot(projection = '3d')\n\ntheta = np.linspace(0, 2 * np.pi, 100)\nz = 0\nr = 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\nax.plot(x, y, z)\n\n## We can shift the same plot by choosing different values of z.\n# z = 3\n# ax.plot(x, y, z)\n\n## for z in np.linspace(0, 1, 100):\n##   ax.plot(x, y, z)\n\nplt.show()\n\n\n\n\nBut what if we link r and z?\n\n# mpl.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.add_subplot(projection = '3d')\n\ntheta = np.linspace(0, 2 * np.pi, 100)\nz = 0\nr = 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\nax.plot(x, y, z)\n\n## We can shift the same plot by choosing different values of z.\n# z = 3\n# ax.plot(x, y, z)\n\n## for z in np.linspace(0, 1, 100):\n##   ax.plot(x, y, z)\n\nplt.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#contour-plots",
    "href": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#contour-plots",
    "title": "Vectors and Geometry of Space",
    "section": "",
    "text": "import matplotlib as mpl\nfrom mpl_toolkits.mplot3d import Axes3D\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# mpl.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.add_subplot(projection = '3d')\n\ntheta = np.linspace(0, 2 * np.pi, 100)\nz = 0\nr = 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\nax.plot(x, y, z)\n\n## We can shift the same plot by choosing different values of z.\n# z = 3\n# ax.plot(x, y, z)\n\n## for z in np.linspace(0, 1, 100):\n##   ax.plot(x, y, z)\n\nplt.show()\n\n\n\n\nBut what if we link r and z?\n\n# mpl.rcParams['legend.fontsize'] = 10\n\nfig = plt.figure()\nax = fig.add_subplot(projection = '3d')\n\ntheta = np.linspace(0, 2 * np.pi, 100)\nz = 0\nr = 1\nx = r * np.sin(theta)\ny = r * np.cos(theta)\nax.plot(x, y, z)\n\n## We can shift the same plot by choosing different values of z.\n# z = 3\n# ax.plot(x, y, z)\n\n## for z in np.linspace(0, 1, 100):\n##   ax.plot(x, y, z)\n\nplt.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#region-plot-inequalities",
    "href": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#region-plot-inequalities",
    "title": "Vectors and Geometry of Space",
    "section": "Region plot (inequalities)",
    "text": "Region plot (inequalities)\n\n# from itertools import product\n\n# def cartesian_product(*arrays):\n#     la = len(arrays)\n#     dtype = np.result_type(*arrays)\n#     arr = np.empty([len(a) for a in arrays] + [la], dtype=dtype)\n#     for i, a in enumerate(np.ix_(*arrays)):\n#         arr[...,i] = a\n#     return arr.reshape(-1, la)\n\n\n# fig = plt.figure()\n# ax = fig.add_subplot(projection='3d')\n\n\n# xd = np.linspace(0,1,100)\n# yd = np.linspace(0,1,100)\n# zd = np.linspace(0,1,100)\n# products =   cartesian_product(xd, yd, zd)\n\n\n# for x, y, z in products:\n    \n#     ax.scatter(x, y, z)\n\n\n\n# ax.set_xlabel('X Label')\n# ax.set_ylabel('Y Label')\n# ax.set_zlabel('Z Label')\n\n# plt.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#vectors-in-sympy",
    "href": "C0calculusII/lectures/11_1VectorsGeometryofSpace.html#vectors-in-sympy",
    "title": "Vectors and Geometry of Space",
    "section": "Vectors in sympy",
    "text": "Vectors in sympy\n\nfrom sympy.vector import CoordSys3D\nN = CoordSys3D('N')\n\n\nv = 2*N.i + N.j #Defines a vector\n\n\nfrom sympy.vector import Vector\nVector.zero\ntype(Vector.zero)\nN.i + Vector.zero\nVector.zero == 2*Vector.zero\n\nTrue\n\n\nDot(&) and Cross product(^):\n\nv1 = 2*N.i + 3*N.j - N.k\nv2 = N.i - 4*N.j + N.k\nv1.dot(v2)\nv1.cross(v2)\nv2.cross(v1)\n\n\nv1 & v2\nv1 ^ v2\n\n\\(\\displaystyle - \\mathbf{\\hat{i}_{N}} + \\left(-3\\right)\\mathbf{\\hat{j}_{N}} + \\left(-11\\right)\\mathbf{\\hat{k}_{N}}\\)\n\n\n\n%matplotlib inline\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# Creating data\nx = np.linspace(-5, 5, 100)\ny = np.linspace(-5, 5, 100)\nX, Y = np.meshgrid(x, y)\nZ = np.sin(X) + np.cos(Y)\n\n# Creating a 3D plot\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\n# Plotting the 3D contour\nax.contour3D(X, Y, Z, 50, cmap='viridis')\n\n# Customizing the plot\nax.set_xlabel('X-axis')\nax.set_ylabel('Y-axis')\nax.set_zlabel('Z-axis')\nax.set_title('Basic 3D Contour Plot')\n\n# Displaying the plot\nplt.show()\n\n\n\n\n\nfrom mpl_toolkits.mplot3d import axes3d\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\nfig = plt.figure()\nax = fig.add_subplot(projection = '3d')\n\nX, Y, Z = axes3d.get_test_data(0.05)\nax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)\ncset = ax.contour(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)\ncset = ax.contour(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)\n\nax.set_xlabel('X')\nax.set_xlim(-40, 40)\nax.set_ylabel('Y')\nax.set_ylim(-40, 40)\nax.set_zlabel('Z')\nax.set_zlim(-100, 100)\n\nplt.show()\n\n\n\n\n\nimport plotly.graph_objects as go\nimport numpy as np\nnp.random.seed(1)\n\nN = 70\n\nfig = go.Figure(data=[go.Mesh3d(x=(70*np.random.randn(N)),\n                   y=(55*np.random.randn(N)),\n                   z=(40*np.random.randn(N)),\n                   opacity=0.5,\n                   color='rgba(244,22,100,0.6)'\n                  )])\n\nfig.update_layout(\n    scene = dict(\n        xaxis = dict(nticks=4, range=[-100,100],),\n                     yaxis = dict(nticks=4, range=[-50,100],),\n                     zaxis = dict(nticks=4, range=[-100,100],),),\n    width=700,\n    margin=dict(r=20, l=10, b=10, t=10))\n\nfig.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_6.html",
    "href": "C0calculusII/lectures/11_6.html",
    "title": "Quadric Surfaces",
    "section": "",
    "text": "import sympy as sp\nimport spb \nfrom spb import PB\n#from sympy import pi \n\nu, v = sp.symbols(\"u, v\")\na, b, c = 1, 1, 1\n\nr = 2 + sp.sin(7 * u + 5 * v)\nexpr = (\n    a * sp.cos(u) * sp.sin(v),\n    b * sp.sin(u) * sp.sin(v),\n    c * sp.cos(v)\n)\n\nspb.plot3d_parametric_surface(*expr, (u, 0, 2 * sp.pi), (v, 0, sp.pi), \"expr\", backend=PB, use_cm=True)\n\n\n                                                \n\n\n&lt;spb.backends.plotly.plotly.PlotlyBackend at 0x1464b64b16d0&gt;\n\n\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Function to generate ellipsoid points\ndef generate_ellipsoid(a, b, c, num_points=100):\n    u = np.linspace(0, 2 * np.pi, num_points)\n    v = np.linspace(0, np.pi, num_points)\n    x = a * np.outer(np.cos(u), np.sin(v))\n    y = b * np.outer(np.sin(u), np.sin(v))\n    z = c * np.outer(np.ones(np.size(u)), np.cos(v))\n    return x, y, z\n\n# Initial parameters\na, b, c = 1, 1, 1\n\n# Generate initial ellipsoid points\nx, y, z = generate_ellipsoid(a, b, c)\n\n# Create the figure\nfig = make_subplots(rows=1, cols=1, specs=[[{'type': 'surface'}]])\n\n# Add the initial ellipsoid\nfig.add_trace(go.Surface(x=x, y=y, z=z, colorscale='Viridis', showscale=False))\n\n# Set fixed axis limits and aspect ratio\nfig.update_layout(\n    title=f'Ellipsoid: a={a}, b={b}, c={c}',\n    scene=dict(\n        xaxis_title='X',\n        yaxis_title='Y',\n        zaxis_title='Z',\n        xaxis=dict(range=[-3, 3]),\n        yaxis=dict(range=[-3, 3]),\n        zaxis=dict(range=[-3, 3]),\n        aspectmode='cube'  # Fix aspect ratio\n    )\n)\n\n# Create sliders for semi-major axes a, b, and c\nfig.update_layout(\n    sliders=[\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis a: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.1,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(i/10, b, c)[0]], \n                             'y': [generate_ellipsoid(i/10, b, c)[1]], \n                             'z': [generate_ellipsoid(i/10, b, c)[2]]},\n                          {'title': f'Ellipsoid: a={i/10:.1f}, b={b}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis a\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis b: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.3,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(a, i/10, c)[0]], \n                             'y': [generate_ellipsoid(a, i/10, c)[1]], \n                             'z': [generate_ellipsoid(a, i/10, c)[2]]},\n                          {'title': f'Ellipsoid: a={a}, b={i/10:.1f}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis b\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis c: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.5,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(a, b, i/10)[0]], \n                             'y': [generate_ellipsoid(a, b, i/10)[1]], \n                             'z': [generate_ellipsoid(a, b, i/10)[2]]},\n                          {'title': f'Ellipsoid: a={a}, b={b}, c={i/10:.1f}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis c\n        }\n    ]\n)\n\n# Show the figure\nfig.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_6.html#elliptic-paraboloid",
    "href": "C0calculusII/lectures/11_6.html#elliptic-paraboloid",
    "title": "Quadric Surfaces",
    "section": "Elliptic Paraboloid",
    "text": "Elliptic Paraboloid\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Function to generate elliptic paraboloid points\ndef generate_paraboloid(a, b, c, num_points=100):\n    x = np.linspace(-2, 2, num_points)\n    y = np.linspace(-2, 2, num_points)\n    x, y = np.meshgrid(x, y)\n    z = c * (x**2 / a + y**2 / b)  # Equation of elliptic paraboloid\n    return x, y, z\n\n# Initial parameters\na, b, c = 1, 1, 1\n\n# Generate initial paraboloid points\nx, y, z = generate_paraboloid(a, b, c)\n\n# Create the figure\nfig = make_subplots(rows=1, cols=1, specs=[[{'type': 'surface'}]])\n\n# Add the initial paraboloid\nfig.add_trace(go.Surface(x=x, y=y, z=z, colorscale='Viridis', showscale=False))\n\n# Set fixed axis limits and aspect ratio\nfig.update_layout(\n    title=f'Elliptic Paraboloid: a={a}, b={b}, c={c}',\n    scene=dict(\n        xaxis_title='X',\n        yaxis_title='Y',\n        zaxis_title='Z',\n        xaxis=dict(range=[-3, 3]),\n        yaxis=dict(range=[-3, 3]),\n        zaxis=dict(range=[0, 3]),\n        aspectmode='cube'  # Fix aspect ratio\n    )\n)\n\n# Create sliders for parameters a, b, and c\nfig.update_layout(\n    sliders=[\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter a: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.1,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(i/10, b, c)[0]], \n                             'y': [generate_paraboloid(i/10, b, c)[1]], \n                             'z': [generate_paraboloid(i/10, b, c)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={i/10:.1f}, b={b}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for parameter a\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter b: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.3,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(a, i/10, c)[0]], \n                             'y': [generate_paraboloid(a, i/10, c)[1]], \n                             'z': [generate_paraboloid(a, i/10, c)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={a}, b={i/10:.1f}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for parameter b\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter c: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.5,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(a, b, i/10)[0]], \n                             'y': [generate_paraboloid(a, b, i/10)[1]], \n                             'z': [generate_paraboloid(a, b, i/10)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={a}, b={b}, c={i/10:.1f}'}]\n                } for i in range(1, 21)]  # Steps for parameter c\n        }\n    ]\n)\n\n# Show the figure\nfig.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_6Quadric.html",
    "href": "C0calculusII/lectures/11_6Quadric.html",
    "title": "Quadric Surfaces",
    "section": "",
    "text": "# Imports\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n\nEllipsoid\n\nimport sympy as sp\nimport spb \nfrom spb import PB\n#from sympy import pi \n\nu, v = sp.symbols(\"u, v\")\na, b, c = 1, 1, 1\n\nr = 2 + sp.sin(7 * u + 5 * v)\nexpr = (\n    a * sp.cos(u) * sp.sin(v),\n    b * sp.sin(u) * sp.sin(v),\n    c * sp.cos(v)\n)\n\nspb.plot3d_parametric_surface(*expr, (u, 0, 2 * sp.pi), (v, 0, sp.pi), \"expr\", backend=PB, use_cm=True)\n\n\n                                                \n\n\n&lt;spb.backends.plotly.plotly.PlotlyBackend at 0x14a715f53fa0&gt;\n\n\nWith sliders:\n\n# Function to generate ellipsoid points\ndef generate_ellipsoid(a, b, c, num_points=100):\n    u = np.linspace(0, 2 * np.pi, num_points)\n    v = np.linspace(0, np.pi, num_points)\n    x = a * np.outer(np.cos(u), np.sin(v))\n    y = b * np.outer(np.sin(u), np.sin(v))\n    z = c * np.outer(np.ones(np.size(u)), np.cos(v))\n    return x, y, z\n\n# Initial parameters\na, b, c = 1, 1, 1\n\n# Generate initial ellipsoid points\nx, y, z = generate_ellipsoid(a, b, c)\n\n# Create the figure\nfig = make_subplots(rows=1, cols=1, specs=[[{'type': 'surface'}]])\n\n# Add the initial ellipsoid\nfig.add_trace(go.Surface(x=x, y=y, z=z, colorscale='Viridis', showscale=False))\n\n# Set fixed axis limits and aspect ratio\nfig.update_layout(\n    title=f'Ellipsoid: a={a}, b={b}, c={c}',\n    scene=dict(\n        xaxis_title='X',\n        yaxis_title='Y',\n        zaxis_title='Z',\n        xaxis=dict(range=[-3, 3]),\n        yaxis=dict(range=[-3, 3]),\n        zaxis=dict(range=[-3, 3]),\n        aspectmode='cube'  # Fix aspect ratio\n    )\n)\n\n# Create sliders for semi-major axes a, b, and c\nfig.update_layout(\n    sliders=[\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis a: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.1,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(i/10, b, c)[0]], \n                             'y': [generate_ellipsoid(i/10, b, c)[1]], \n                             'z': [generate_ellipsoid(i/10, b, c)[2]]},\n                          {'title': f'Ellipsoid: a={i/10:.1f}, b={b}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis a\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis b: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.3,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(a, i/10, c)[0]], \n                             'y': [generate_ellipsoid(a, i/10, c)[1]], \n                             'z': [generate_ellipsoid(a, i/10, c)[2]]},\n                          {'title': f'Ellipsoid: a={a}, b={i/10:.1f}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis b\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Semi-Major Axis c: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.5,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_ellipsoid(a, b, i/10)[0]], \n                             'y': [generate_ellipsoid(a, b, i/10)[1]], \n                             'z': [generate_ellipsoid(a, b, i/10)[2]]},\n                          {'title': f'Ellipsoid: a={a}, b={b}, c={i/10:.1f}'}]\n                } for i in range(1, 21)]  # Steps for semi-major axis c\n        }\n    ]\n)\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\n\n\nElliptic Paraboloid\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Function to generate elliptic paraboloid points\ndef generate_paraboloid(a, b, c, num_points=100):\n    x = np.linspace(-2, 2, num_points)\n    y = np.linspace(-2, 2, num_points)\n    x, y = np.meshgrid(x, y)\n    z = c * (x**2 / a + y**2 / b)  # Equation of elliptic paraboloid\n    return x, y, z\n\n# Initial parameters\na, b, c = 1, 1, 1\n\n# Generate initial paraboloid points\nx, y, z = generate_paraboloid(a, b, c)\n\n# Create figure\nfig = make_subplots(rows=1, cols=1, specs=[[{'type': 'surface'}]])\n\n# Add the initial paraboloid\nfig.add_trace(go.Surface(x=x, y=y, z=z, colorscale='Viridis', showscale=False))\n\n# Set fixed axis limits and aspect ratio\nfig.update_layout(\n    title=f'Elliptic Paraboloid: a={a}, b={b}, c={c}',\n    scene=dict(\n        xaxis_title='X',\n        yaxis_title='Y',\n        zaxis_title='Z',\n        xaxis=dict(range=[-3, 3]),\n        yaxis=dict(range=[-3, 3]),\n        zaxis=dict(range=[0, 3]),\n        aspectmode='cube'  # Fix aspect ratio\n    )\n)\n\n# Create sliders for parameters a, b, and c\nfig.update_layout(\n    sliders=[\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter a: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.1,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(i/10, b, c)[0]], \n                             'y': [generate_paraboloid(i/10, b, c)[1]], \n                             'z': [generate_paraboloid(i/10, b, c)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={i/10:.1f}, b={b}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for parameter a\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter b: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.3,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(a, i/10, c)[0]], \n                             'y': [generate_paraboloid(a, i/10, c)[1]], \n                             'z': [generate_paraboloid(a, i/10, c)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={a}, b={i/10:.1f}, c={c}'}]\n                } for i in range(1, 21)]  # Steps for parameter b\n        },\n        {\n            'active': 0,\n            'yanchor': 'top',\n            'xanchor': 'left',\n            'currentvalue': {\n                'prefix': 'Parameter c: ',\n                'visible': True,\n                'xanchor': 'right'\n            },\n            'pad': {'b': 10},\n            'len': 0.9,\n            'x': 0.1,\n            'y': -0.5,\n            'steps': [{\n                'label': f'{i/10:.1f}',\n                'method': 'update',\n                'args': [{'x': [generate_paraboloid(a, b, i/10)[0]], \n                             'y': [generate_paraboloid(a, b, i/10)[1]], \n                             'z': [generate_paraboloid(a, b, i/10)[2]]},\n                          {'title': f'Elliptic Paraboloid: a={a}, b={b}, c={i/10:.1f}'}]\n                } for i in range(1, 21)]  # Steps for parameter c\n        }\n    ]\n)\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\n\n\nHyperbolic Paraboloid\nThe hyperbolic paraboloid\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Generate the grid of x and y values\nx = np.linspace(-2, 2, 200)\ny = np.linspace(-2, 2, 200)\nx, y = np.meshgrid(x, y)\n\n# Define the circular mask\nradius = 2\nmask = x**2 + y**2 &lt;= radius**2\n\n\n# Define the hyperbolic paraboloid equation z = (x^2 / a^2) - (y^2 / b^2)\na = 1  # scale factor for x\nb = 1  # scale factor for y\nz = (x**2 / a**2) - (y**2 / b**2)\n\n# Apply the mask to the z values\nz[~mask] = np.nan  # Set values outside the circle to NaN for visualization\n\n# Create the 3D surface plot\nfig = go.Figure(data=[go.Surface(z=z, x=x, y=y, colorscale='Viridis', showscale=False)])\n\n# Add titles and labels\nfig.update_layout(title='Hyperbolic Paraboloid (Pringle Chip Shape)',\n                  scene=dict(\n                      xaxis_title='X-axis',\n                      yaxis_title='Y-axis',\n                      zaxis_title='Z-axis',\n                      aspectmode='manual',\n                      aspectratio=dict(x=1, y=1, z=0.5)\n                  ))\n\n# Show the plot\nfig.show()\n\n\n                                                \n\n\nAlternative method:\n\n# Source: https://dkmj.org/ipython/2415s16/xy-hyperboloid.html\nimport plotly.offline as py\nfrom plotly.graph_objs import *\nimport numpy as np\nfrom numpy import pi, cos, sin, exp, log, sqrt\npy.init_notebook_mode()\n\ndef curve(rfun,tmin=-2,tmax=2,tpts=200,color='black'):\n    domain = np.linspace(tmin,tmax,tpts)\n    r = [[rfun(t)[i] for t in domain] for i in range(3)]\n    trace = Scatter3d(x=r[0],y=r[1],z=r[2],mode='lines',\n                      line=Line(color=color,width=3))\n    return(trace)\n\ndef snake(u,v):\n    lu, lv = len(u), len(v)\n    path = []\n\n    i, j = 0, 0\n    istep, jstep = 1, 1\n    while(i &lt; lu):\n        while(0 &lt;= j &lt; lv):\n            path.append((u[i],v[j]))\n            j += jstep\n        j -= jstep\n        i += istep\n        jstep *= -1\n\n    i -= istep\n    i -= istep\n    istep *= -1\n    while(0 &lt;= j &lt; lv):\n        while(0 &lt;= i &lt; lu):\n            path.append((u[i],v[j]))\n            i += istep\n        i -= istep\n        j += jstep\n        istep *= -1\n    return path\n\ndef surface(rfun,tmin=-2,tmax=2,tpts=20,umin=-2,umax=2,upts=20,color='black'):\n    t, u = np.linspace(tmin,tmax,tpts), np.linspace(umin,umax,upts)\n    path = snake(t,u)\n    r = [[rfun(t,u)[i] for (t,u) in path] for i in range(3)]\n    trace = Scatter3d(x=r[0],y=r[1],z=r[2],mode='lines',\n                      line=Line(color=color,width=3))\n    return(trace)\n\nf = lambda x,y: x*y\nxmin=-1\nxmax=1\nymin=-1\nymax=1\ns = surface(lambda t,u: (t,u,f(t,u)),color='green',tmin=xmin,tmax=xmax,umin=ymin,umax=ymax) #surface z=f(x,y)\npy.iplot(Figure(data=Data([s])))\n\n/home/fes33/Documents/Work_-_Web/Worldlines/env/lib/python3.9/site-packages/plotly/graph_objs/_deprecations.py:378: DeprecationWarning: plotly.graph_objs.Line is deprecated.\nPlease replace it with one of the following more specific types\n  - plotly.graph_objs.scatter.Line\n  - plotly.graph_objs.layout.shape.Line\n  - etc.\n\n/home/fes33/Documents/Work_-_Web/Worldlines/env/lib/python3.9/site-packages/plotly/graph_objs/_deprecations.py:31: DeprecationWarning: plotly.graph_objs.Data is deprecated.\nPlease replace it with a list or tuple of instances of the following types\n  - plotly.graph_objs.Scatter\n  - plotly.graph_objs.Bar\n  - plotly.graph_objs.Area\n  - plotly.graph_objs.Histogram\n  - etc."
  },
  {
    "objectID": "C0calculusII/lectures/11_6aQuadric.html",
    "href": "C0calculusII/lectures/11_6aQuadric.html",
    "title": "Quadric Surfaces",
    "section": "",
    "text": "# Imports\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n\nEllipsoid\n\nimport sympy as sp\nimport spb \nfrom spb import PB\n#from sympy import pi \n\nu, v = sp.symbols(\"u, v\")\na, b, c = 1, 1, 2\n\nexpr = (\n    a * sp.cos(u) * sp.sin(v),\n    b * sp.sin(u) * sp.sin(v),\n    c * sp.cos(v)\n)\n\nspb.plot3d_parametric_surface(*expr, (u, 0, 2 * sp.pi), (v, 0, sp.pi), \"\", backend=PB, use_cm=True)\n\n\n                                                \n\n\n&lt;spb.backends.plotly.plotly.PlotlyBackend at 0x1515a9cdbd90&gt;\n\n\n\n\nElliptic Paraboloid\n\nx=np.linspace(-1,1, 100),\ny=np.linspace(-1,1, 100)\n\nX,Y=np.meshgrid(x,y)\nZ=X**2+Y**2#\n\nsurf = go.Figure(data=[go.Surface(\n    x=X, \n    y=Y, \n    z=Z,\n    colorscale='RdBu',\n    hoverinfo='skip'\n    \n)])\n\nsurf.update_layout(\n    scene = dict(\n        xaxis = dict(nticks=4),\n                     zaxis = dict(nticks=4, range=[0,1],),),\n    width=700,\n    margin=dict(r=20, l=10, b=10, t=10))\n\n# Update layout\nsurf.update_layout(\n    scene=dict(\n        xaxis_title='X Axis',\n        yaxis_title='Y Axis',\n        zaxis_title='Z Axis'\n    )\n)\n\n# Show the plot\nsurf.show()\n\n\n                                                \n\n\n\n\nHyperbolic Paraboloid\nThe hyperbolic paraboloid\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Generate the grid of x and y values\nx = np.linspace(-2, 2, 200)\ny = np.linspace(-2, 2, 200)\nx, y = np.meshgrid(x, y)\n\n# Define the circular mask\nradius = 2\nmask = x**2 + y**2 &lt;= radius**2\n\n\ncolor1 = 'orange'\ncolor2 = 'yellow'\n\na = 1  # scale factor for x\nb = 1  # scale factor for y\nz = (x**2 / a**2) - (y**2 / b**2)\n\n# Apply the mask to the z values\nz[~mask] = np.nan  # Set values outside the circle to NaN for visualization\n\n# Create the 3D surface plot\nfig = go.Figure(data=[go.Surface(z=z, x=x, y=y, \n                contours = {\n                        \"x\": {\"show\": False, \"start\":-5, \"end\": 5, \"size\": 1, \"color\":\"gray\"},\n                        \"y\": {\"show\": False, \"start\": -5, \"end\": 5, \"size\": 1, \"color\":\"gray\"}\n                    }, \n\n                colorscale=[[0, color1], [1,color2]], \n                hoverinfo = 'skip', showscale=False)])\n\n# Add titles and labels\nfig.update_layout(title='Hyperbolic Paraboloid (Pringle Chip Shape)',\n                  scene=dict(\n                      xaxis_title='X-axis',\n                      yaxis_title='Y-axis',\n                      zaxis_title='Z-axis',\n                      aspectmode='manual',\n                      aspectratio=dict(x=1, y=1, z=0.5)\n                  ))\n\n# fig.update_layout(\n#     scene = dict(\n#         xaxis = dict(visible=False),\n#         yaxis = dict(visible=False),\n#         zaxis =dict(visible=False)\n#         )\n#     )\n\n# Show the plot\nfig.show()"
  },
  {
    "objectID": "C0calculusII/lectures/11_6bQuadric.html",
    "href": "C0calculusII/lectures/11_6bQuadric.html",
    "title": "Quadric Surfaces (continued)",
    "section": "",
    "text": "Hyperbolic Paraboloid\nThe hyperbolic paraboloid\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Generate the grid of x and y values\nx = np.linspace(-2, 2, 200)\ny = np.linspace(-2, 2, 200)\nx, y = np.meshgrid(x, y)\n\n# Define the circular mask\nradius = 2\nmask = x**2 + y**2 &lt;= radius**2\n\n\n# Define the hyperbolic paraboloid equation z = (x^2 / a^2) - (y^2 / b^2)\na = 1  # scale factor for x\nb = 1  # scale factor for y\nz = (x**2 / a**2) - (y**2 / b**2)\n\n# Apply the mask to the z values\nz[~mask] = np.nan  # Set values outside the circle to NaN for visualization\n\n# Create the 3D surface plot\nfig = go.Figure(data=[go.Surface(z=z, x=x, y=y, colorscale='Viridis', showscale=False)])\n\n# Add titles and labels\nfig.update_layout(title='Hyperbolic Paraboloid (Pringle Chip Shape)',\n                  scene=dict(\n                      xaxis_title='X-axis',\n                      yaxis_title='Y-axis',\n                      zaxis_title='Z-axis',\n                      aspectmode='manual',\n                      aspectratio=dict(x=1, y=1, z=0.5)\n                  ))\n\n# Show the plot\nfig.show()\n\n\n                                                \n\n\nAlternative method:\n\n# Source: https://dkmj.org/ipython/2415s16/xy-hyperboloid.html\nimport plotly.offline as py\nfrom plotly.graph_objs import *\nimport numpy as np\nfrom numpy import pi, cos, sin, exp, log, sqrt\npy.init_notebook_mode()\n\ndef curve(rfun,tmin=-2,tmax=2,tpts=200,color='black'):\n    domain = np.linspace(tmin,tmax,tpts)\n    r = [[rfun(t)[i] for t in domain] for i in range(3)]\n    trace = Scatter3d(x=r[0],y=r[1],z=r[2],mode='lines',\n                      line=Line(color=color,width=3))\n    return(trace)\n\ndef snake(u,v):\n    lu, lv = len(u), len(v)\n    path = []\n\n    i, j = 0, 0\n    istep, jstep = 1, 1\n    while(i &lt; lu):\n        while(0 &lt;= j &lt; lv):\n            path.append((u[i],v[j]))\n            j += jstep\n        j -= jstep\n        i += istep\n        jstep *= -1\n\n    i -= istep\n    i -= istep\n    istep *= -1\n    while(0 &lt;= j &lt; lv):\n        while(0 &lt;= i &lt; lu):\n            path.append((u[i],v[j]))\n            i += istep\n        i -= istep\n        j += jstep\n        istep *= -1\n    return path\n\ndef surface(rfun,tmin=-2,tmax=2,tpts=20,umin=-2,umax=2,upts=20,color='black'):\n    t, u = np.linspace(tmin,tmax,tpts), np.linspace(umin,umax,upts)\n    path = snake(t,u)\n    r = [[rfun(t,u)[i] for (t,u) in path] for i in range(3)]\n    trace = Scatter3d(x=r[0],y=r[1],z=r[2],mode='lines',\n                      line=Line(color=color,width=3))\n    return(trace)\n\nf = lambda x,y: x*y\nxmin=-1\nxmax=1\nymin=-1\nymax=1\ns = surface(lambda t,u: (t,u,f(t,u)),color='green',tmin=xmin,tmax=xmax,umin=ymin,umax=ymax) #surface z=f(x,y)\npy.iplot(Figure(data=Data([s])))\n\n/home/fes33/Documents/Work_-_Web/Worldlines/env/lib/python3.9/site-packages/plotly/graph_objs/_deprecations.py:378: DeprecationWarning:\n\nplotly.graph_objs.Line is deprecated.\nPlease replace it with one of the following more specific types\n  - plotly.graph_objs.scatter.Line\n  - plotly.graph_objs.layout.shape.Line\n  - etc.\n\n\n/home/fes33/Documents/Work_-_Web/Worldlines/env/lib/python3.9/site-packages/plotly/graph_objs/_deprecations.py:31: DeprecationWarning:\n\nplotly.graph_objs.Data is deprecated.\nPlease replace it with a list or tuple of instances of the following types\n  - plotly.graph_objs.Scatter\n  - plotly.graph_objs.Bar\n  - plotly.graph_objs.Area\n  - plotly.graph_objs.Histogram\n  - etc."
  },
  {
    "objectID": "C0calculusII/lectures/13_3PartialDerivatives.html",
    "href": "C0calculusII/lectures/13_3PartialDerivatives.html",
    "title": "Partial Derivatives",
    "section": "",
    "text": "import sympy as sp\nx, y = sp.symbols('x y')\n\n# Define the function\nf = x * y**2\n\n\n# Calculate the partial derivatives\npartial_x = sp.diff(f, x)  # Partial derivative with respect to x\npartial_y = sp.diff(f, y)  # Partial derivative with respect to y\n\n# Display the results\nprint(\"Partial derivatives wrt x and y:\")\ndisplay(partial_x, partial_y)\n\nPartial derivatives wrt x and y:\n\n\n\\(\\displaystyle y^{2}\\)\n\n\n\\(\\displaystyle 2 x y\\)\n\n\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define the range for x and y\npi = np.pi\nx = np.linspace(-4 * pi, 4*pi, 100)\ny = np.linspace(-1, 1, 100)\nx, y = np.meshgrid(x, y)\n\n# Calculate z based on the given function\nz = y**2 * np.cos(x * y)\n\n\ncolor1 = 'orange'\ncolor2 = 'orange'\n# Create the surface plot with custom colors\nfig = go.Figure(data=[go.Surface(z=z, x=x, y=y, colorscale=[[0, color1], [1,color2]], showscale=False, hoverinfo = 'skip')])\n\n# Update layout for background and titles\nfig.update_layout(\n    title='Surface Plot of z = y^2 cos(xy)',\n    scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z')\n)\n\nshowbackground = False\n\nfig.update_layout(scene = dict(\n                    xaxis = dict(\n                         backgroundcolor=\"rgb(200, 200, 230)\",\n                         gridcolor=\"white\",\n                         showbackground=showbackground,\n                         zerolinecolor=\"black\",),\n                    yaxis = dict(\n                        backgroundcolor=\"rgb(230, 200,230)\",\n                        gridcolor=\"white\",\n                        showbackground=showbackground,\n                        zerolinecolor=\"black\"),\n                    zaxis = dict(\n                        backgroundcolor=\"rgb(230, 230,200)\",\n                        gridcolor=\"white\",\n                        showbackground=showbackground,\n                        zerolinecolor=\"black\",),),\n                    # width=700,\n                    margin=dict(\n                    r=10, l=10,\n                    b=10, t=26)\n                  )\n\n\n# Show the plot\nfig.show()\n\n\n                                                \n\n\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Define the paraboloid z = x^2 + y^2\ndef paraboloid(x, y):\n    return x**2 + y**2\n\n# Create a grid for x and y\nx = np.linspace(-2.5, 2.5, 100)\ny = np.linspace(-2.5, 2.5, 100)\nx, y = np.meshgrid(x, y)\nz = paraboloid(x, y)\n\nmask = x**2 + y**2 &lt;= 4\nz[~mask] = np.nan  # Set values outside the circle to NaN for visualization\n\n\n# Define the intersection plane x = 1\nx_intersection = 1\ny_intersection = np.linspace(-2, 2, 100)\nz_intersection = paraboloid(x_intersection, y_intersection)\n\n# Point of tangency on the intersection\ny_tangent_point = 1  # You can choose another point on the parabola\nz_tangent_point = paraboloid(x_intersection, y_tangent_point)\n\n# Calculate the slope of the tangent line\n# Derivative of z with respect to y: dz/dy = 2y\ntangent_slope = 2 * y_tangent_point  # at y = 0, this is 0\n\n# Create the tangent line in the plane z = k + m(y - y0)\ny_tangent = np.linspace(y_tangent_point - 1, y_tangent_point + 1, 100)\nz_tangent = z_tangent_point + tangent_slope * (y_tangent - y_tangent_point)\n\n# Create the figure\nfig = go.Figure()\n\n# Add paraboloid \ncolor1 = 'orange'\ncolor2 = 'orange'\nfig.add_trace(go.Surface(z=z, x=x, y=y, colorscale=[[0, color1], [1,color2]], opacity=0.7, name='Paraboloid', hoverinfo = 'skip'))\n\n# Add intersecting plane\nfig.add_trace(go.Scatter3d(x=[x_intersection]*len(y_intersection), \n                             y=y_intersection, \n                             z=z_intersection, \n                             mode='lines', \n                             name='Intersection Parabola', \n                             line=dict(color='red', width=5)))\n\n# Add tangent line\nfig.add_trace(go.Scatter3d(x=[x_intersection]*len(y_tangent), \n                             y=y_tangent, \n                             z=z_tangent, \n                             mode='lines', \n                             name='Tangent Line', \n                             line=dict(color='blue', width=5)))\n\n# Update layout\nfig.update_layout(title='Paraboloid with Intersection and Tangent Line',\n                  scene=dict(xaxis_title='X', yaxis_title='Y', zaxis_title='Z'),\n                  width=800, height=600,\n                  paper_bgcolor='white')\n\n# Show the plot\nfig.show()"
  },
  {
    "objectID": "C0calculusI/lectures/4derivativesapplications.html",
    "href": "C0calculusI/lectures/4derivativesapplications.html",
    "title": "Applications of Derivatives",
    "section": "",
    "text": "import sympy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sympy as sp\nfrom sympy.plotting import plot\n\nx = sp.symbols('x')\n#Define the variable and the function\n\nf = x**(2)**(1/3) +(x+2)\npoint = sp.pi / 4  # Point of tangency\nrng = [-1, 1] # Range\n\n#______________________________-\n\nslope = f.diff(x).subs(x, point)  # Calculate the slope\ntangent_line = slope * (x - point) + f.subs(x, point)\np1 = plot(f, (x, rng[0], rng[1]), show=False, line_color='blue')\np2 = plot(tangent_line, (x, point - 0.5, point+0.5), show=False, line_color='red', line_dash='--', label='Tangent line')\np1.extend(p2)\n\n\np1.show()"
  },
  {
    "objectID": "C0calculusI/lectures/4derivativesapplications.html#maximaminima",
    "href": "C0calculusI/lectures/4derivativesapplications.html#maximaminima",
    "title": "Applications of Derivatives",
    "section": "Maxima/Minima",
    "text": "Maxima/Minima\n\nx = sp.symbols('x')\nequation = x*sp.exp(-x**2/10)\n\nfirstDeriv = equation.diff(x)\nsecondDeriv = firstDeriv.diff(x)\n\ncriticalPoints = list(sp.solveset(firstDeriv, x))\ncriticalPointsY = [equation.subs(x, a) for a in criticalPoints]\n\nxx = np.linspace(-10, 10, 1000)\nyy = sp.lambdify(x, [equation, firstDeriv, secondDeriv])(xx)\nplt.plot(xx, np.transpose(yy))\nplt.plot(criticalPoints, criticalPointsY, 'k*')\nplt.legend(['f', \"f'\", \"f''\"])\nplt.show()"
  },
  {
    "objectID": "C0calculusI/home_calculusI.html#midterm",
    "href": "C0calculusI/home_calculusI.html#midterm",
    "title": "Calculus I",
    "section": "Midterm",
    "text": "Midterm\nThe midterm will include everything studied in class up till (and including) section 4.1."
  },
  {
    "objectID": "C0TopologicalMaterials/home_topmat.html",
    "href": "C0TopologicalMaterials/home_topmat.html",
    "title": "Topological Materials",
    "section": "",
    "text": "SSH to Floquet"
  },
  {
    "objectID": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html",
    "href": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html",
    "title": "SSH to Floquet",
    "section": "",
    "text": "Highlights\n\nDescribes a 1D lattice.\nHopping amplitudes are staggered\nTopologicla Invariant: Winding number which results in edge states."
  },
  {
    "objectID": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#su-schrieffer-heeger-ssh-model",
    "href": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#su-schrieffer-heeger-ssh-model",
    "title": "SSH to Floquet",
    "section": "",
    "text": "Highlights\n\nDescribes a 1D lattice.\nHopping amplitudes are staggered\nTopologicla Invariant: Winding number which results in edge states."
  },
  {
    "objectID": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#haldane-model",
    "href": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#haldane-model",
    "title": "SSH to Floquet",
    "section": "Haldane Model",
    "text": "Haldane Model\n\n2D, tight-binding model\nTopological Invariant: Chern number associated with edge states.\n\n\\(C &gt; 0 \\implies\\) two gapped curves, except for the cross-over at 0."
  },
  {
    "objectID": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#floquet-topological-insulators",
    "href": "C0TopologicalMaterials/lectures/01_SSHtoFloquet.html#floquet-topological-insulators",
    "title": "SSH to Floquet",
    "section": "Floquet Topological Insulators",
    "text": "Floquet Topological Insulators\n\nBehave like Topological Insulators (TI) due to periodic driving.\nFloquet spectra (equivalent of eigenvalue spectra)\n\n\nRudner Model\n\n\nGraphene-Light Model"
  },
  {
    "objectID": "C0calculusII/lectures/14_2DoubleIntegrals.html",
    "href": "C0calculusII/lectures/14_2DoubleIntegrals.html",
    "title": "Partial Derivatives",
    "section": "",
    "text": "#Example 4: Section 14.1, Thomas 15th edition.\nfrom sympy import symbols, integrate\n\n# Define the variables\nx, y = symbols('x y')\n\n# Define the function to integrate\nf = 16 - x**2 - y**2\n\n# Define the bounds\nx_lower = y**2 / 4\nx_upper = (y + 2)/4\ny_lower = 0\ny_upper = 2\n\n# Compute the double integral\nres = integrate(f, (x, x_lower, x_upper))\nresult = integrate(res, (y, y_lower, y_upper))\n\n# Display the result\ndisplay(res)\nprint('Now integrating over y')\ndisplay(result)\n\n\\(\\displaystyle \\frac{y^{6}}{192} - \\frac{y^{2} \\left(16 - y^{2}\\right)}{4} + \\left(16 - y^{2}\\right) \\left(\\frac{y}{4} + \\frac{1}{2}\\right) - \\frac{\\left(\\frac{y}{4} + \\frac{1}{2}\\right)^{3}}{3}\\)\n\n\nNow integrating over y\n\n\n\\(\\displaystyle \\frac{20803}{1680}\\)"
  },
  {
    "objectID": "C0calculusII/home_calculusII.html#project",
    "href": "C0calculusII/home_calculusII.html#project",
    "title": "Calculus II",
    "section": "",
    "text": "As announced in class, there will be a project.\nThe task: Reproduce 3 figures (two 2D and one 3D) from your textbook.\nNote that the figure must be accurate in terms of annotations and labels, tick marks, precision etc.\nFurthermore:\n\nThe project will be done in groups of 3.\nThe marks will be credited as bonus (i.e. they will not have a separate category)\nThere will be a viva in the 15th week.\nThe individual with the lowest midterm marks in the group will most likely give the viva (although other members of the group can be called upon too.)"
  },
  {
    "objectID": "C0calculusII/lectures/14_6SphericalCylindrical.html",
    "href": "C0calculusII/lectures/14_6SphericalCylindrical.html",
    "title": "Spherical and Cylindrical Coodrinates",
    "section": "",
    "text": "import plotly.graph_objects as go\nimport numpy as np\n\n# Function to generate spherical coordinates\ndef sphere(radius, resolution=100):\n    phi = np.linspace(0, np.pi, resolution)  # Latitude\n    theta = np.linspace(0, 2 * np.pi, resolution)  # Longitude\n    phi, theta = np.meshgrid(phi, theta)\n\n    # Parametric equations for the sphere\n    x = radius * np.sin(phi) * np.cos(theta)\n    y = radius * np.sin(phi) * np.sin(theta)\n    z = radius * np.cos(phi)\n    \n    return x, y, z\n\n# Function to generate cone coordinates\ndef cone(angle, height=2, resolution=100):\n    # Angle in radians\n    angle = np.radians(angle)\n    \n    # Generating the cone surface\n    z = np.linspace(0, height, resolution)  # Height of the cone\n    theta = np.linspace(0, 2 * np.pi, resolution)  # Angle around the cone\n    Z, Theta = np.meshgrid(z, theta)\n    \n    # Radius at each height level (linear tapering from the base to the apex)\n    R = (height - Z) * np.tan(angle)  # Radius varies with height\n\n    # Parametric equations for the cone\n    X = R * np.cos(Theta)\n    Y = R * np.sin(Theta)\n    \n    return X, Y, Z\n\n# Create the figure\nfig = go.Figure()\n\n# Add sphere to the plot\nradius_slider_value = 1.0  # Initial radius\nx_sphere, y_sphere, z_sphere = sphere(radius_slider_value)\nfig.add_trace(go.Surface(x=x_sphere, y=y_sphere, z=z_sphere, colorscale='Viridis', opacity=0.5, showscale=False))\n\n# Add cone to the plot\nangle_slider_value = 30  # Initial angle of the cone\nx_cone, y_cone, z_cone = cone(angle_slider_value)\nfig.add_trace(go.Surface(x=x_cone, y=y_cone, z=z_cone, colorscale='YlOrRd', opacity=0.6, showscale=False))\n\n# Set the layout with sliders for radius and cone angle\nfig.update_layout(\n    sliders=[dict(\n        yanchor=\"top\",\n        xanchor=\"left\",\n        currentvalue=dict(\n            visible=True,\n            xanchor=\"center\",\n            font=dict(size=20),\n        ),\n        steps=[\n            dict(\n                label=f\"Radius {r:.1f}\",\n                method=\"relayout\",\n                args=[{\"scene.camera\": {\"eye\": {\"x\": 1.25 * r, \"y\": 1.25 * r, \"z\": 1.25 * r}}}]  \n            )\n            for r in np.arange(0.5, 3.1, 0.5)\n        ]\n    )]\n)\nfig.show()"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html#text-and-reference-books",
    "href": "C0noneqthermo/home_noneqthermo.html#text-and-reference-books",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Text and Reference Books",
    "text": "Text and Reference Books\nSome texts, online or otherwise are given below:\n\nLinda Reichl: A Course in Modern Statistical Physics.\n\nChapter 7 is about Brownian Motion and Fluctuation Dissipation\n\nKerson Huang: Introduction to Statistical Physics\n\nSee chapter 14\n\nBikkin, Lyapilin: Non-equilibrium thermodynamics and physical kinetics\nAttard: Non-Equilibrium Thermodynamics and Statistical Mechanics\nBalakrishnan:\nPottier: Non-Equilibrium Statistical Physics\nRopke: Non-Equilibrium Statistical Physics\nPeliti & Pigolotti: Stochastic Thermodynamics\n\nSee Chapter 4: Jarzynski and Crooks relations\n\nBanerjee: Open Quantum Systems\n\nOther texts\n\nWoyczyński - Diffusion Processes, Jump Processes, and Stochastic Differential Equations\nDavid Tong: Lectures on Kinetic Theory\nKardar: Statistical Theory of Particles"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html#topics",
    "href": "C0noneqthermo/home_noneqthermo.html#topics",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Topics",
    "text": "Topics\n\nReview of phenomenological thermodynamics\nBrownian motion\nLangevin and Fokker Planck equation\nJarzynski and Crooks relations\n\nLangevin equation\nFokker Planck equation\nLinear Response Theory"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevin.html",
    "href": "C0noneqthermo/lectures/langevin.html",
    "title": "Langevin Equation",
    "section": "",
    "text": "We are going to stochastically solve the Langevin Equation.\nWe take the Langevin equation. There is a stochastic force in there which is Gaussian in nature.\nWe will (1) use Euler’s method to generate a realization but for that we first need (2) a sampled Gaussian distribution.\nConsult Gerd Ropke’s text on non-equilibrium thermodynamics."
  },
  {
    "objectID": "C0noneqthermo/lectures/langevin.html#sampling-a-gaussian",
    "href": "C0noneqthermo/lectures/langevin.html#sampling-a-gaussian",
    "title": "Langevin Equation",
    "section": "Sampling a Gaussian",
    "text": "Sampling a Gaussian\n\nManually (Box-Fuller method)\nLet’s try the Box-Fuller method.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef SampleGaussian(num = 1000):\n\n    u = np.random.rand(num)\n    u1 = u[:int(num/2)]\n    u2 = u[int(num/2):]\n\n    z0 = np.sqrt(-2*np.log(u1)) * np.cos(2 * np.pi* u1)\n    z1 = np.sqrt(-2*np.log(u1)) * np.sin(2 * np.pi* u2)\n    z = np.concatenate((z0,z1))\n    return z\n\n\nplt.hist(SampleGaussian(), bins = 10)\n\n(array([  8.,  20., 195., 196., 301., 119.,  72.,  52.,  29.,   8.]),\n array([-2.71806518, -2.09685307, -1.47564096, -0.85442884, -0.23321673,\n         0.38799538,  1.0092075 ,  1.63041961,  2.25163173,  2.87284384,\n         3.49405595]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\nAutomatic (use some library)"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevin.html#numerical-solution-of-the-langevin-equation",
    "href": "C0noneqthermo/lectures/langevin.html#numerical-solution-of-the-langevin-equation",
    "title": "Langevin Equation",
    "section": "Numerical solution of the Langevin equation",
    "text": "Numerical solution of the Langevin equation\n\nUse the Euler method\n\\(v_k^{(m)} = v_{k-1}^{(m)} + h (-\\gamma v_{k-1}^{(m)} + r_{k-1}^{m})\\)\n$M = 1000 (Number of realizations), $ $N = 24000 time steps, $ $h = 0.025, $ \\(t_N - t_0 = 600 s,\\) \\(\\gamma = 5; D = 1\\)\n\n\nSolve it directly\n\nFor one realization: Create N random variables.\n\n\ndef eulerlangevin(vk_1, rk_1, h, gamma ):\n    return vk_1 + h * (-gamma * vk_1 + rk_1)\n\n\ndef langevinrealizations(h = 0.025, samples = 100, realizations = 10, v0 = 1, gamma = 5, D = 1):\n    \"\"\"\n    Create multiple langevin realizations\n    Arguments:\n        v0 = Initial velocity\n        h = time step\n        gamma = friction\n        D = Diffusion\n\n        time (not passed but total simulation time = h*samples)\n\n    \"\"\"\n\n    time = np.linspace(0,h*samples, samples)\n\n    allvk = np.empty((realizations, samples))\n    allgaussians = np.empty((realizations, samples))\n\n    for m in range(realizations):\n        gaussianrv = SampleGaussian(samples)\n        vk = np.array([])\n        for i in range(len(gaussianrv)):\n            if i == 0:\n                vk = np.array([v0]) #np.append(vk, eulerlangevin(v0, gaussianrv[0], h, gamma))\n            else:\n                vk = np.append(vk, eulerlangevin(vk[i-1], gaussianrv[i-1], h, gamma))\n\n        allvk[m] = vk\n        allgaussians[m] = gaussianrv\n\n    return time, allvk, allgaussians\ntime, allvk, allgaussians = langevinrealizations(samples = 1000, h = 0.025, gamma = 5, D = 1, realizations = 10)\n\nWe plot some realizations.\n\nn = 50\nplt.plot(time[:n], allvk[0][:n])\nplt.plot(time[:n], allvk[1][:n])\nplt.plot(time[:n], allvk[2][:n])"
  },
  {
    "objectID": "C0noneqthermo/lectures/linearresponsetheory.html",
    "href": "C0noneqthermo/lectures/linearresponsetheory.html",
    "title": "Linear Response Theory",
    "section": "",
    "text": "Non-equilibrium thermodynamics uses a phenomenological approach since enough information is not really available.\nG\n\n Formalism  \n\n1st + 2nd Law\n\n 1st + 2nd Law   \n\nGibbs equation\n\n Gibbs equation   \n\n1st + 2nd Law-&gt;Gibbs equation\n\n    \n\nRate of Entropy Production\n\n Rate of Entropy Production   \n\nGibbs equation-&gt;Rate of Entropy Production\n\n    \n\nLevel of Energy Dissipation\n\n Level of Energy Dissipation   \n\nRate of Entropy Production-&gt;Level of Energy Dissipation\n\n    \n\nBalance equations\n\n Balance equations   \n\nBalance equations-&gt;Rate of Entropy Production\nWe will not go far from equilibrium. The transport and rate equations will be expressed in linear forms, and the Onsager reciprocal relations are valid."
  },
  {
    "objectID": "C0noneqthermo/lectures/linearresponsetheory.html#stationary-states",
    "href": "C0noneqthermo/lectures/linearresponsetheory.html#stationary-states",
    "title": "Linear Response Theory",
    "section": "Stationary States",
    "text": "Stationary States\nIntensive properties that specify the state of a substance are time independent in equilibrium systems and in nonequilibrium stationary states (which only happens in non-isolated systems of course).\nExtensive properties specifying the state of a system with boundaries are also independent of time, and the boundaries are stationary in a coordinate system.\nThe stationary state of a substance at any point is related to the stationary state of the system\nThe total entropy will not change:\n\\[\n\\frac{dS}{dt} = \\frac{dS_e}{dt} + \\frac{dS_i}{dt} = 0\n\\]\nAlso in terms of entropy currents (in and out) a continuity equation can be written:\n\\[\n\\frac{dS_i}{dt} + (J_{s,in} - J_{s,out}) = 0\n\\]\n\n\n\\[\n\\begin{align}\n\\frac{dS_e}{dt} &= \\text{Entropy exchange between system and surroundings} \\\\\n\\frac{dS_i}{dt} &= \\text{Entropy production inside}\n\\end{align}\n\\]\nEntropy production (\\(dS_i \\geq 0\\)) and since \\(dS_e/dt\\) is greater than 0 (system need not be isolated):\n\\[\n\\frac{dS_e}{dt} = -\\frac{dS_i}{dt} = (J_{s,in} - J_{s,out}) &lt; 0\n\\]\n\n\nEntropy exchange with the environment is negative\n\n\nThe stationary state is maintained through the decrease in entropy exchanged between the system and its surrounding.\nThe total entropy produced within the system must be discharged across the boundary at stationary state.\n\n\n\n\n\n\n\n\n\nD\n\n Formalism  \n\nStationary state\n\n Stationary state   \n\nBoundary conditions do not change with time\n\n Boundary conditions do not change with time   \n\nStationary state-&gt;Boundary conditions do not change with time\n\n    \n\nIsolated system\n\n Isolated system   \n\nSteady state not possible\n\n Steady state not possible   \n\nIsolated system-&gt;Steady state not possible\n\n    \n\ndS_e/dt = 0\n\n dS_e/dt = 0   \n\nSteady state not possible-&gt;dS_e/dt = 0\n\n    \n\nEntropy created cannot be discharged to maintain steady state (dS_e/dt = 0)\n\n Entropy created cannot be discharged to maintain steady state (dS_e/dt = 0)   \n\nSteady state not possible-&gt;Entropy created cannot be discharged to maintain steady state (dS_e/dt = 0)\n\n    \n\nAdiabatic system\n\n Adiabatic system   \n\nAdiabatic system-&gt;Steady state not possible\n\n    \n\nEquilibrium\n\n Equilibrium   \n\ndS/dt = dS_e/dt = dS_i/dt = 0\n\n dS/dt = dS_e/dt = dS_i/dt = 0   \n\nEquilibrium-&gt;dS/dt = dS_e/dt = dS_i/dt = 0"
  },
  {
    "objectID": "C0ode/home_ode.html#quizzes",
    "href": "C0ode/home_ode.html#quizzes",
    "title": "Ordinary Differential Equations",
    "section": "",
    "text": "We will three quizzes:\n\nQuiz 1 (5 Marks)\nQuiz 2 (10 marks, 8th week)   \nQuiz 3 (10 marks, 13th week)"
  },
  {
    "objectID": "C0ode/home_ode.html#assignments",
    "href": "C0ode/home_ode.html#assignments",
    "title": "Ordinary Differential Equations",
    "section": "Assignments",
    "text": "Assignments\nAssignment 1\nAssignment 2\nAssignment 3"
  },
  {
    "objectID": "C0ode/home_ode.html#slides-and-notebooks",
    "href": "C0ode/home_ode.html#slides-and-notebooks",
    "title": "Ordinary Differential Equations",
    "section": "Slides and Notebooks",
    "text": "Slides and Notebooks\nYou can use any programming language of your liking. We will most likely use one of python, julia, and R. If you need to set any of these up, either see me or the TA.\n\nPractice questions\nJulia: Quick reference for matrices\nGaussian Elimination\nJulia: ODEs\nSummary of 1st order ODEs"
  },
  {
    "objectID": "C0ode/home_ode.html#course-outline",
    "href": "C0ode/home_ode.html#course-outline",
    "title": "Ordinary Differential Equations",
    "section": "Course Outline",
    "text": "Course Outline\nOutline (pdf)"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "",
    "text": "Based on the report by Parham Radpay.\nBoth the Fokker-Planck and Langevin equations describe the Brownian motion. In general, they also explain the behavior of a system in presence of a random noise and its evolution toward a stationary state i.e., they could also be applied to thermalization processes of non-equilibrium systems."
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#history",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#history",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "History",
    "text": "History"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#kramers-moyal-expansion",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#kramers-moyal-expansion",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "Kramers-Moyal Expansion",
    "text": "Kramers-Moyal Expansion\nKarmers-Moyal expansion (KME) is a useful tool for investigating the FPE. The KME is: - an expansion - of the time development of a time-dependent probability distribution - in terms of the moments of the transition probability.\nOur starting point is the probability density \\(W\\) and the transition probability \\(P\\). We can relate the probability density at time \\(t\\) and at time \\(t+\\tau\\) via:\n\\[\nW(x, t+\\tau) = \\int P(x, t+\\tau|x',t) \\cdot W(x',t) dx'\n\\]\nwhere the integral is carried over all \\(x\\). We can define moments for the transition probability which in our case depend on the initial time \\(t\\), initial position (could be any random variable) \\(x\\), and the time for the transition \\(\\tau\\).\n\\[\nM_n(x', t, \\tau) = \\langle x(t+\\tau)  - x(t) \\rangle|_x' = x(t) = \\int (x-x')^n P(x,t+\\tau| x,t) dx'\n\\]\n\\(P(x, t+\\tau|x',t)\\) can be expressed as the convolution integral of Dirac deltas which we can then replace by its Taylor expansion around \\(x'-x\\): \\[\n\\begin{align*}\nP(x, t+\\tau|x',t) &= \\int \\delta(x-y) P(y, t+\\tau|x',t) dx\\\\\n&=\\sum_{n=0}^\\infty \\int \\frac{(y-x')^n}{n!} (\\frac{-\\partial}{\\partial x})^n \\delta(x'-x)P(y, t+\\tau|x',t) dx'\\\\\n\\end{align*}\n\\]\nThe order of integration and summation has been swapped since the result converges to \\(P(x, t+\\tau|x',t)\\). We now have:\n\\[\n\\begin{align*}\nP(x, t+\\tau|x',t) &= \\bigg[\\sum_{n=0}^\\infty \\frac{1}{n!}\\bigg(\\frac{-\\partial}{\\partial x}\\bigg)^n M_n(x,t,\\tau)\\bigg]\\delta(x'-x]\\\\\n&=[1 + \\sum_{n=1}{\\infty}\\frac{1}{n!}\\bigg(\\frac{-\\partial}{\\partial x}\\bigg)^n M_n(x,t,\\tau)]\\delta(x'-x)\n\\end{align*}\n\\]\n\nBackward KM Expansion\n\n\nMore on the Kramers-Moyal Expansion\n\n\n\nkramersmoyal is a python package for evaluating Kramers-Moyal coeffiecients."
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#langevin-equation",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#langevin-equation",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "Langevin Equation",
    "text": "Langevin Equation\n\nBrownian Motion\n\n\nNon-Linear Langevin Equation"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#fokker-planck-equation",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#fokker-planck-equation",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "Fokker-Planck Equation",
    "text": "Fokker-Planck Equation\n\nWiener and Ornstein-Uhlenbeck Processes"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#solutions",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#solutions",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "Solutions",
    "text": "Solutions"
  },
  {
    "objectID": "C0noneqthermo/lectures/langevinandfokkerplanck.html#relativistic-ornstein-uhlenbeck-process",
    "href": "C0noneqthermo/lectures/langevinandfokkerplanck.html#relativistic-ornstein-uhlenbeck-process",
    "title": "Langevin & Fokker-Planck Equation",
    "section": "Relativistic Ornstein-Uhlenbeck Process",
    "text": "Relativistic Ornstein-Uhlenbeck Process"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html#progression",
    "href": "C0noneqthermo/home_noneqthermo.html#progression",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Progression",
    "text": "Progression\n\nWeek 1-2\nStrand A: Stochastic thermodynamics\nWe will develop the Langevin and Fokker Planck Equations. Ultimately we will head towards the GSKL equations following Banerjee. Specifically you might hear:\n\nLangevin Equation\nFokker Planck Equation\nLiouville theorem\nSmoluchowski equation\nKramers Moyal expansion\n\nTexts:\n\nBalakrishnan (Chapters 1-6)\nZwanzig (Chapters 1-3)\nBanerjee: Open Quantum Systems (Chapter 3)"
  },
  {
    "objectID": "C0ode/coursematerial/01.html",
    "href": "C0ode/coursematerial/01.html",
    "title": "Differential Equations",
    "section": "",
    "text": "asd"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html#topics-subject-to-change",
    "href": "C0noneqthermo/home_noneqthermo.html#topics-subject-to-change",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Topics (Subject to change)",
    "text": "Topics (Subject to change)\n\nBrownian Motion\nLangevin, Fokker-Planck, Master Equation:\n\nBalakrishnan (Chapters 1-6)\nZwanzig (Chapters 1-3)\nBanerjee: Open Quantum Systems (Chapter 3)\n\n\n\nTransport Phenomena/Boltzmann Equation\n\nMarder, Condensed Matter Physics, Chapter 17.\nLink\n\nBBKGY Hierarchy - Kremer: An Introduction to the Boltzmann Equation and Transport Processes in Gases\n\nReview of phenomenological thermodynamics\nBrownian motion\nJarzynski and Crooks relations\nBoltzmann (Transport) Equation\n\n\n\nOpen Quantum Systems\n\nH theorem\nGKLS Equations\nOpen quantum systems\n\nLangevin equation\nFokker Planck equation\nLinear Response Theory"
  },
  {
    "objectID": "C0noneqthermo/coursematerial/homeworks.html",
    "href": "C0noneqthermo/coursematerial/homeworks.html",
    "title": "Homework",
    "section": "",
    "text": "Prove Balakrishnan equations 2.1 to 2.5\n[python] Plot the distribution in 2.1"
  },
  {
    "objectID": "C0noneqthermo/coursematerial/homeworks.html#section",
    "href": "C0noneqthermo/coursematerial/homeworks.html#section",
    "title": "Homework",
    "section": "",
    "text": "Prove Balakrishnan equations 2.1 to 2.5\n[python] Plot the distribution in 2.1"
  },
  {
    "objectID": "C0ode/coursematerial/01-MatricesJulia.html",
    "href": "C0ode/coursematerial/01-MatricesJulia.html",
    "title": "Matrix operations with Julia",
    "section": "",
    "text": "You can define a matrix in Julia.\nFor more info see julia docs"
  },
  {
    "objectID": "index.html#undergraduate",
    "href": "index.html#undergraduate",
    "title": "Course Hub",
    "section": "Undergraduate",
    "text": "Undergraduate\nCalculus I - MT101\nDifferential Equations & Linear Algebra - MT102\nCalculus II - MT202"
  },
  {
    "objectID": "index.html#graduate",
    "href": "index.html#graduate",
    "title": "Course Hub",
    "section": "Graduate",
    "text": "Graduate\nNon-equilibrium Thermodynamics - ES696"
  },
  {
    "objectID": "C0ode/coursematerial/01-MatricesJulia.html#python",
    "href": "C0ode/coursematerial/01-MatricesJulia.html#python",
    "title": "Matrix operations with Julia",
    "section": "Python",
    "text": "Python\n\nimport numpy as np\n\n# Define the matrix\nmatrix = np.array([[2, 4, 6],\n                   [1, 3, 5],\n                   [9, 7, 8]])\n\n# Compute the trace of the matrix\nmatrix_trace = np.trace(matrix)\n\n# Compute the inverse of the matrix\nmatrix_inverse = np.linalg.inv(matrix)\n\n# Compute the transpose of the matrix\nmatrix_transpose = np.transpose(matrix)\n\n# Print the results\nprint(\"Matrix:\")\nprint(matrix)\n\nprint(\"\\nTrace of the matrix:\")\nprint(matrix_trace)\n\nprint(\"\\nInverse of the matrix:\")\nprint(matrix_inverse)\n\nprint(\"\\nTranspose of the matrix:\")\nprint(matrix_transpose)\n\nMatrix:\n[[2 4 6]\n [1 3 5]\n [9 7 8]]\n\nTrace of the matrix:\n13\n\nInverse of the matrix:\n[[-1.83333333  1.66666667  0.33333333]\n [ 6.16666667 -6.33333333 -0.66666667]\n [-3.33333333  3.66666667  0.33333333]]\n\nTranspose of the matrix:\n[[2 1 9]\n [4 3 7]\n [6 5 8]]\n\n\n\nFor more info see julia docs"
  },
  {
    "objectID": "C0ode/coursematerial/01-MatricesJulia.html#solving-linear-equations",
    "href": "C0ode/coursematerial/01-MatricesJulia.html#solving-linear-equations",
    "title": "Matrix operations with Julia",
    "section": "Solving linear equations",
    "text": "Solving linear equations\nSay we have a linear system of equations. How do we find out in advance whether there is a solution to the system or not.\nThe determinant ‘determines’ it for us (hence the name):\n\\[\\begin{align}\n1x + 2y + 3z = 6\\\\\n2x + 4y + 6z = 12\\\\\n3x + 6y + 9z = 18\\\\\n\\end{align}\\]\n\nusing LinearAlgebra\n# using LinearSolve\n\n# Define the coefficient matrix A and the right-hand side vector b\nA = [\n    1  2  3;\n    2  4  6;\n    3  6  9\n]\n\nb = [6, 12, 18]\n\n# Calculate the determinant of A\ndet_A = det(A)\nprintln(\"Determinant of A: $det_A\")\n\nDeterminant of A: 0.0"
  },
  {
    "objectID": "C0ode/home_ode.html#other-info",
    "href": "C0ode/home_ode.html#other-info",
    "title": "Ordinary Differential Equations",
    "section": "Other info",
    "text": "Other info\nCourse TA: Ms. Misbah Shaheen Email: misbah.shaheen [at] giki.edu.pk"
  },
  {
    "objectID": "C0ode/coursematerial/01-GaussElimination.html",
    "href": "C0ode/coursematerial/01-GaussElimination.html",
    "title": "Gaussian Elimination",
    "section": "",
    "text": "We can either create a matrix randomly or feed one:\n\n# A = rand(1:10, 4,4)\nA  = [1 -1 1 0; -1 1 -1 0; 0 10 -1 90; 20 10 0 80]\n\n4×4 Matrix{Int64}:\n  1  -1   1   0\n -1   1  -1   0\n  0  10  -1  90\n 20  10   0  80\n\n\nFirst we use row 1 as pivot and eliminate the rest of the non-zero entries in the first column:\n\nA[2, :] = A[2, :] + A[1, :]\nA\n\n4×4 Matrix{Int64}:\n  1  -1   1   0\n  0   0   0   0\n  0  10  -1  90\n 20  10   0  80\n\n\n\nA[4, :] = A[4, :] - 20 * A[1, :]\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1   0\n 0   0    0   0\n 0  10   -1  90\n 0  30  -20  80\n\n\nNow we need to swap the rows:\n\nA[[2,3,4], :] = A[[3,4,2], :];\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1   0\n 0  10   -1  90\n 0  30  -20  80\n 0   0    0   0\n\n\nNow we can use row 2 as the pivot and remove all the non-zero entries below:\n\nA[3, :] = A[3, :] - 3 * A[2, :];\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1     0\n 0  10   -1    90\n 0   0  -17  -190\n 0   0    0     0\n\n\n\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1     0\n 0  10   -1    90\n 0   0  -17  -190\n 0   0    0     0"
  },
  {
    "objectID": "C0ode/lectures/01-GaussElimination.html",
    "href": "C0ode/lectures/01-GaussElimination.html",
    "title": "Gaussian Elimination",
    "section": "",
    "text": "We can either create a matrix randomly or feed one:\n# A = rand(1:10, 4,4)\nA  = [1 -1 1 0; -1 1 -1 0; 0 10 -1 90; 20 10 0 80]\n\n4×4 Matrix{Int64}:\n  1  -1   1   0\n -1   1  -1   0\n  0  10  -1  90\n 20  10   0  80\nFirst we use row 1 as pivot and eliminate the rest of the non-zero entries in the first column:\nA[2, :] = A[2, :] + A[1, :]\nA\n\n4×4 Matrix{Int64}:\n  1  -1   1   0\n  0   0   0   0\n  0  10  -1  90\n 20  10   0  80\nA[4, :] = A[4, :] - 20 * A[1, :]\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1   0\n 0   0    0   0\n 0  10   -1  90\n 0  30  -20  80\nNow we need to swap the rows:\nA[[2,3,4], :] = A[[3,4,2], :];\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1   0\n 0  10   -1  90\n 0  30  -20  80\n 0   0    0   0\nNow we can use row 2 as the pivot and remove all the non-zero entries below:\nA[3, :] = A[3, :] - 3 * A[2, :];\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1     0\n 0  10   -1    90\n 0   0  -17  -190\n 0   0    0     0\nA\n\n4×4 Matrix{Int64}:\n 1  -1    1     0\n 0  10   -1    90\n 0   0  -17  -190\n 0   0    0     0"
  },
  {
    "objectID": "C0ode/lectures/01-MatricesJulia.html",
    "href": "C0ode/lectures/01-MatricesJulia.html",
    "title": "Matrix operations with Julia",
    "section": "",
    "text": "You can define a matrix in Julia.\nFor more info see julia docs"
  },
  {
    "objectID": "C0ode/lectures/01-MatricesJulia.html#solving-linear-equations",
    "href": "C0ode/lectures/01-MatricesJulia.html#solving-linear-equations",
    "title": "Matrix operations with Julia",
    "section": "Solving linear equations",
    "text": "Solving linear equations\nSay we have a linear system of equations. How do we find out in advance whether there is a solution to the system or not.\nThe determinant ‘determines’ it for us (hence the name):\n\\[\\begin{align}\n1x + 2y + 3z = 6\\\\\n2x + 4y + 6z = 12\\\\\n3x + 6y + 9z = 18\\\\\n\\end{align}\\]\n\nusing LinearAlgebra\n# using LinearSolve\n\n# Define the coefficient matrix A and the right-hand side vector b\nA = [\n    1  2  3;\n    2  4  6;\n    3  6  9\n]\n\nb = [6, 12, 18]\n\n# Calculate the determinant of A\ndet_A = det(A)\nprintln(\"Determinant of A: $det_A\")\n\nDeterminant of A: 0.0"
  },
  {
    "objectID": "C0TopologicalMaterials/lectures/01_basics.html",
    "href": "C0TopologicalMaterials/lectures/01_basics.html",
    "title": "Topological Insulators",
    "section": "",
    "text": "Some quick questions:\nTopologically trivial vs. non-trivial: A “topologically trivial” material is one whose electronic band structure can be continuously deformed into a simple, standard state [e.g. atomic state] without encountering any topological barriers, meaning its properties can be easily changed by local perturbations.\nA “topologically non-trivial” material has a unique, protected electronic structure that cannot be smoothly transformed into a trivial state, often exhibiting robust surface states that are insensitive to local disturbances like defects or impurities\nTopological phase transition:"
  },
  {
    "objectID": "C0ode/lectures/01-GaussElimination.html#infinitely-many-solutions",
    "href": "C0ode/lectures/01-GaussElimination.html#infinitely-many-solutions",
    "title": "Gaussian Elimination",
    "section": "Infinitely many solutions",
    "text": "Infinitely many solutions\nWhen the number of equations is fewer than the number of unknowns, infinitely many solutions exist.\n\nusing LinearAlgebra;\n\n# Define the augmented matrix (coefficients) and right-hand side vector\nA = [\n    3.0   2.0   2.0  -5.0;\n    0.6   1.5   1.5  -5.4;\n    1.2  -0.3  -0.3   2.4\n];\n\nb = [8.0; 2.7; 2.1];\n\n# Solve the system to find a particular solution\nx_particular = A \\ b;\n\nprintln(\"Particular solution: \", x_particular);\n\nParticular solution: [2.000000000000001, 0.5000000000000006, 0.5000000000000006, 2.0653174743575485e-16]\n\n\nNote that julia has given one solution (not infinite).\n\n# Compute the null space of A\nN = nullspace(A)\n\nprintln(\"\\nNull space of A:\")\nprintln(N)\n\n# Check the dimensions of the null space\nprintln(\"\\nNumber of free parameters (nullity of A): \", size(N, 2))\n\n# Generate a general solution using free parameters\nc = [1.0, 0.0]  # Example free parameters for the null space\nx_general = x_particular .+ N * c\n\nprintln(\"\\nGeneral solution with c = [1.0, 0.0]: \", x_general)\n\n# Verify the solution\nprintln(\"\\nVerification: A * x_general ≈ b\")\nprintln(A * x_general)\n\n\nNull space of A:\n[-0.2607387739647174 0.17892817483944756; 0.9215731099604074 0.2251732732761658; 0.12138198589846322 -0.940885972633956; 0.26073877396471784 -0.1789281748394475]\n\nNumber of free parameters (nullity of A): 2\n\nGeneral solution with c = [1.0, 0.0]: [1.7392612260352835, 1.4215731099604079, 0.6213819858984637, 0.26073877396471806]\n\nVerification: A * x_general ≈ b\n[8.000000000000004, 2.7, 2.1000000000000023]"
  },
  {
    "objectID": "C0ode/lectures/01-GaussElimination.html#row-echelon-form",
    "href": "C0ode/lectures/01-GaussElimination.html#row-echelon-form",
    "title": "Gaussian Elimination",
    "section": "Row echelon form",
    "text": "Row echelon form\n\nfunction reduced_row_echelon_form(A)\n    A = float(copy(A))  # Make a copy to avoid mutating the original matrix\n    rows, cols = size(A)\n    pivot_row = 1\n    \n    for col in 1:cols\n        # Find the pivot in the current column\n        pivot = argmax(abs.(A[pivot_row:rows, col])) + pivot_row - 1\n        if A[pivot, col] ≈ 0\n            continue  # Skip this column if all entries are zero\n        end\n        \n        # Swap the pivot row with the current row\n        A[[pivot_row, pivot], :] = A[[pivot, pivot_row], :]\n        \n        # Normalize the pivot row\n        A[pivot_row, :] ./= A[pivot_row, col]\n        \n        # Eliminate entries below the pivot\n        for r in (pivot_row + 1):rows\n            A[r, :] .-= A[r, col] * A[pivot_row, :]\n        end\n        \n        # Move to the next row\n        pivot_row += 1\n        if pivot_row &gt; rows\n            break\n        end\n    end\n    \n    return A\nend\n\nA = [3 2 1 3; 2 1 1 0; 6 2 4 6]\nreduced_row_echelon_form(A)\n\n3×4 Matrix{Float64}:\n 1.0  0.333333   0.666667   1.0\n 0.0  1.0       -1.0        0.0\n 0.0  0.0        1.0       -1.80144e16"
  },
  {
    "objectID": "C0ode/lectures/00-PracticeQuestions.html",
    "href": "C0ode/lectures/00-PracticeQuestions.html",
    "title": "Practice Questions",
    "section": "",
    "text": "Kreyszig is limited in terms of practice questions and some of you have asked for alternatives.\nTwo books you can use to circumvent that are:\n\nDennis G. Zill’s Advanced Engineering Mathematics\nDean G. Duffy’s Advanced Engineering Mathematics\n\nZill’s book in particular has a lot of practice problems.\nNotwithstanding, you can use julia to create your own problems. All you need is a way to create a matrix.\nThe following creates a 4x3 matrix with numbers randomly filled from 1 to 10.\n\nmat = rand(1:10, 4, 3)\n\n4×3 Matrix{Int64}:\n  9   7  10\n  1  10   1\n 10   6   9\n  2   1   4\n\n\nYou can make changes to it and generate as many questions as you want."
  },
  {
    "objectID": "C0noneqthermo/lectures/lecture_1.html",
    "href": "C0noneqthermo/lectures/lecture_1.html",
    "title": "Lecture 1",
    "section": "",
    "text": "Liouville theorem and Liouville operator\nLangevin and Fokker-Planck Equations\nKramers-Moyal Expansion\n\nPossibly review: - Hamilton’s equations\n\n\n\n\n\nappealing approach to nonequilibrium statistical mechanics that is physically transparent\nequation-of-motion method or, more accurately, the Langevin equation approach.\nwrite an appropriate equation of motion for a subsystem, in which its interaction with the other degrees of freedom of the system is modeled in terms of a stochastic or random ‘force’ with suitable statistical properties.\nThe task then is to extract the statistical properties of the subsystem of interest, starting from its equation of motion\nLangevin equation method in its original or simplest form turns out to be too drastic an approximation to be applicable, as it stands, to this case. At the molecular level, the behavior of fluids poses a complicated many-body problem.\nHence the more rigorous approach is the BBGKY hierarchy.\n\n\n\n\n\n\n\n\nBBGKY_Hierarchy\n\n  \n\nBBGKY\n\n BBGKY Hierarchy (Infinite integro-differential equations)   \n\nSimplified\n\n Simplified System of Equations (Under certain conditions)   \n\nBBGKY-&gt;Simplified\n\n    \n\nBoltzmann\n\n Boltzmann Equation (A convenient starting point)   \n\nSimplified-&gt;Boltzmann\n\n    \n\nFokkerPlanck\n\n Fokker-Planck Equation (More tractable in specific instances)   \n\nBoltzmann-&gt;FokkerPlanck\n\n   \n\n\n\n\n\n\nthe FPE approximation is valid (in the context of the fluid system) for the description of the motion of a particle of mass m in a fluid consisting of molecules of mass m_mol &lt;&lt; m.\nthe Fokker-Planck equation is just another facet of the Langevin equation"
  },
  {
    "objectID": "C0noneqthermo/lectures/lecture_1.html#session-a",
    "href": "C0noneqthermo/lectures/lecture_1.html#session-a",
    "title": "Lecture 1",
    "section": "",
    "text": "Liouville theorem and Liouville operator\nLangevin and Fokker-Planck Equations\nKramers-Moyal Expansion\n\nPossibly review: - Hamilton’s equations\n\n\n\n\n\nappealing approach to nonequilibrium statistical mechanics that is physically transparent\nequation-of-motion method or, more accurately, the Langevin equation approach.\nwrite an appropriate equation of motion for a subsystem, in which its interaction with the other degrees of freedom of the system is modeled in terms of a stochastic or random ‘force’ with suitable statistical properties.\nThe task then is to extract the statistical properties of the subsystem of interest, starting from its equation of motion\nLangevin equation method in its original or simplest form turns out to be too drastic an approximation to be applicable, as it stands, to this case. At the molecular level, the behavior of fluids poses a complicated many-body problem.\nHence the more rigorous approach is the BBGKY hierarchy.\n\n\n\n\n\n\n\n\nBBGKY_Hierarchy\n\n  \n\nBBGKY\n\n BBGKY Hierarchy (Infinite integro-differential equations)   \n\nSimplified\n\n Simplified System of Equations (Under certain conditions)   \n\nBBGKY-&gt;Simplified\n\n    \n\nBoltzmann\n\n Boltzmann Equation (A convenient starting point)   \n\nSimplified-&gt;Boltzmann\n\n    \n\nFokkerPlanck\n\n Fokker-Planck Equation (More tractable in specific instances)   \n\nBoltzmann-&gt;FokkerPlanck\n\n   \n\n\n\n\n\n\nthe FPE approximation is valid (in the context of the fluid system) for the description of the motion of a particle of mass m in a fluid consisting of molecules of mass m_mol &lt;&lt; m.\nthe Fokker-Planck equation is just another facet of the Langevin equation"
  },
  {
    "objectID": "C0noneqthermo/lectures/lecture_1.html#session-b",
    "href": "C0noneqthermo/lectures/lecture_1.html#session-b",
    "title": "Lecture 1",
    "section": "Session B:",
    "text": "Session B:"
  },
  {
    "objectID": "C0noneqthermo/home_noneqthermo.html#week-3",
    "href": "C0noneqthermo/home_noneqthermo.html#week-3",
    "title": "Non-equilibrium Thermodynamics",
    "section": "Week 3",
    "text": "Week 3\nStrand B: Transport phenomena\nIn tandem we will develop the Boltzmann equation. Some concepts:\n\nBoltzmann equation\nRelaxation time approximation.\n\nTexts:\n\nMarder, Condensed Matter Physics (Chapter 17)\nLink\n\n\nWeek 4-6\nBrownian Motion & Diffusion\n\n\nWeek 7-8\nBoltzmann Equation and H-theorem\nBBKGY Hierarchy - Kremer: An Introduction to the Boltzmann Equation and Transport Processes in Gases\n\n\nWeek 9+\nSDEs\n\n\nWeek 10+\nJarzynski, Crooks?"
  },
  {
    "objectID": "C0ode/home_ode.html",
    "href": "C0ode/home_ode.html",
    "title": "Ordinary Differential Equations",
    "section": "",
    "text": "We will three quizzes:\n\nQuiz 1 (5 Marks)\nQuiz 2 (10 marks, 8th week)   \nQuiz 3 (10 marks, 13th week)"
  },
  {
    "objectID": "C0QuickReference/julia/matrices.html",
    "href": "C0QuickReference/julia/matrices.html",
    "title": "Julia and Matrices",
    "section": "",
    "text": "For the most part we’ll use LinearAlgebra package.\nusing LinearAlgebra"
  },
  {
    "objectID": "C0QuickReference/julia/matrices.html#initializing-matrices",
    "href": "C0QuickReference/julia/matrices.html#initializing-matrices",
    "title": "Julia and Matrices",
    "section": "Initializing matrices",
    "text": "Initializing matrices\n\nSetting type\nYou can initialize a float 64 matrix in the following way.\n\nm = Matrix{Float64}([1 1;2 2])\n\n2×2 Matrix{Float64}:\n 1.0  1.0\n 2.0  2.0\n\n\n\n\nIdentity and diagonal matrices\nI represents an identity matrix. You don’t really need to specify its dimensions.\n\n3* I + [1 1 1; 1 1 1; 1 1 1]\n\n3×3 Matrix{Int64}:\n 4  1  1\n 1  4  1\n 1  1  4\n\n\nFor a diagonal matrix with different entries along the diagonal:"
  },
  {
    "objectID": "C0QuickReference/julia/matrices.html#extraction-from-matrices",
    "href": "C0QuickReference/julia/matrices.html#extraction-from-matrices",
    "title": "Julia and Matrices",
    "section": "Extraction from matrices",
    "text": "Extraction from matrices\nYou can extract the diagonal from a matrix. Note that c[2,1] is 0. Note the lack of commas.\n\nc  = Diagonal([1 2 3; 2 3 4; 3 7 8])\nc[2,1]\n\n0\n\n\nTo convert a vector (note the commas) into a diagonal matrix use diagm:\n\na = [1, 2, 3, 4]\nDiagonal(a)\n\n4×4 Diagonal{Int64, Vector{Int64}}:\n 1  ⋅  ⋅  ⋅\n ⋅  2  ⋅  ⋅\n ⋅  ⋅  3  ⋅\n ⋅  ⋅  ⋅  4\n\n\nFor a true diagonal matrix (again, no commas)\n\ndiagm(a)\n\n4×4 Matrix{Int64}:\n 1  0  0  0\n 0  2  0  0\n 0  0  3  0\n 0  0  0  4"
  },
  {
    "objectID": "C0QuickReference/julia/matrices.html#list-comprehension",
    "href": "C0QuickReference/julia/matrices.html#list-comprehension",
    "title": "Julia and Matrices",
    "section": "List comprehension",
    "text": "List comprehension"
  },
  {
    "objectID": "C0ode/lectures/02-DiffEqJulia.html",
    "href": "C0ode/lectures/02-DiffEqJulia.html",
    "title": "Solving Differential Equations in Julia",
    "section": "",
    "text": "Julia provides a powerful and efficient way to solve differential equations using the DifferentialEquations.jl package. This tutorial will walk through solving and plotting a simple ordinary differential equation (ODE).\nTo begin, install the necessary packages if you haven’t already:\n\nusing Pkg\nPkg.add([\"DifferentialEquations\", \"Plots\"])\n\nNow, consider the first-order differential equation:\n\\[\ndy/dt = -2y\n\\]\nwith the initial condition y(0) = 1. The following Julia code sets up and solves this equation:\n\nusing DifferentialEquations, Plots\n\nfunction f!(dy, y, p, t)\n    dy[1] = -2y[1]  # dy/dt = -2y\nend\n\ny0 = [1.0]\ntspan = (0.0, 5.0)\n\nprob = ODEProblem(f!, y0, tspan)\nsol = solve(prob)\n\nplot(sol, xlabel=\"Time (t)\", ylabel=\"y(t)\", lw=2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will generate a plot of the exponential decay function y(t) = e^(-2t).\nNotice the indexing with [1] in dy[1] = -2y[1]. Julia’s DifferentialEquations.jl package requires state variables (y) and their derivatives (dy) to be stored in array-like structures rather than scalars. Even for a single equation, they are treated as vectors, allowing the same framework to handle systems of equations.\nFor example, if we had a system of two equations:\n\\[\ndy1/dt = -2y1 + y2\\\\\ndy2/dt = -y1 - y2\n\\]\nwe would define:\n\nfunction system!(dy, y, p, t)\n    dy[1] = -2y[1] + y[2]\n    dy[2] = -y[1] - y[2]\nend\n\nEven though we did not use the parameters p and time t in our simple example, they must still be included in the function definition. This is because DifferentialEquations.jl expects functions with the signature:\n\nf!(dy, y, p, t)\n\nKeeping p allows for easy parameterization of equations. For example, if the decay rate were variable:\n\nfunction f!(dy, y, p, t)\n    dy[1] = -p * y[1]\nend\n\nyou could pass p when defining the problem:\n\nprob = ODEProblem(f!, [1.0], (0.0, 5.0), 2.0)  # p = 2.0\n\nSimilarly, t is useful for time-dependent equations, such as:\n\nfunction f!(dy, y, p, t)\n    dy[1] = -2 * y[1] + sin(t)\nend\n\nThese conventions make it easy to extend the model for more complex scenarios while maintaining compatibility with Julia’s solver ecosystem."
  },
  {
    "objectID": "C0QuickReference/julia/ode.html",
    "href": "C0QuickReference/julia/ode.html",
    "title": "Solving Differential Equations in Julia",
    "section": "",
    "text": "Julia provides a powerful and efficient way to solve differential equations using the DifferentialEquations.jl package. This tutorial will walk through solving and plotting a simple ordinary differential equation (ODE).\nTo begin, install the necessary packages if you haven’t already:\n\nusing Pkg\nPkg.add([\"DifferentialEquations\", \"Plots\"])\n\nNow, consider the first-order differential equation:\n\\[\ndy/dt = -2y\n\\]\nwith the initial condition y(0) = 1. The form of this differential equation is:\n\\[\n\\frac{dy}{dt} = f(y, p, t)\n\\]\nThe DifferentialEquations.jl package, expects the ODE to be defined in terms of a Julia function that takes the arguments y, p and t.\nThe following Julia code sets up and solves this equation:\n\nusing DifferentialEquations, Plots\n\nfunction f!(dy, y, p, t)\n    dy[1] = -2y[1]  # dy/dt = -2y\nend\n\ny0 = [1.0]\ntspan = (0.0, 5.0)\n\nprob = ODEProblem(f!, y0, tspan)\nsol = solve(prob)\n\nplot(sol, xlabel=\"Time (t)\", ylabel=\"y(t)\", lw=2)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis will generate a plot of the exponential decay function y(t) = e^(-2t).\nNote also the indexing with [1] in dy[1] = -2y[1]. Julia’s DifferentialEquations.jl package requires state variables (y) and their derivatives (dy) to be stored in array-like structures rather than scalars. Even for a single equation, they are treated as vectors, allowing the same framework to handle systems of equations.\nFor example, if we had a system of two equations:\n\\[\ndy1/dt = -2y1 + y2\\\\\ndy2/dt = -y1 - y2\n\\]\nwe would define:\n\nfunction system!(dy, y, p, t)\n    dy[1] = -2y[1] + y[2]\n    dy[2] = -y[1] - y[2]\nend\n\nEven though we did not use the parameters p and time t in our simple example, they must still be included in the function definition. This is because DifferentialEquations.jl expects functions with the signature:\n\nf!(dy, y, p, t)\n\nKeeping p allows for easy parameterization of equations. For example, if the decay rate were variable:\n\nfunction f!(dy, y, p, t)\n    dy[1] = -p * y[1]\nend\n\nyou could pass p when defining the problem:\n\nprob = ODEProblem(f!, [1.0], (0.0, 5.0), 2.0)  # p = 2.0\n\nSimilarly, t is useful for time-dependent equations, such as:\n\nfunction f!(dy, y, p, t)\n    dy[1] = -2 * y[1] + sin(t)\nend\n\nThese conventions make it easy to extend the model for more complex scenarios while maintaining compatibility with Julia’s solver ecosystem."
  },
  {
    "objectID": "C0manyBody/home_manybody.html",
    "href": "C0manyBody/home_manybody.html",
    "title": "Many-Body Systems",
    "section": "",
    "text": "Green’s functions/Propagators\nLinear response"
  },
  {
    "objectID": "C0manyBody/home_manybody.html#chapters",
    "href": "C0manyBody/home_manybody.html#chapters",
    "title": "Many-Body Systems",
    "section": "",
    "text": "Green’s functions/Propagators\nLinear response"
  },
  {
    "objectID": "C0manyBody/lectures/kohnsham.html",
    "href": "C0manyBody/lectures/kohnsham.html",
    "title": "Kohn Sham Equations",
    "section": "",
    "text": "There is an analogy that I’d like to create between the many body quantum electronic hamiltonian and the Kohn-Sham equations.\nLike all analogies it would be woefully skimpy on details but when I first started out I thought it was a useful way of looking at things. That and the fact that I like to recast equations into stories.\nConsider the complete many-body electronic hamiltonian:\n\\[\nMany body hamiltonian\n\\]\nI like to think of this way. We have a society of electrons that we would like to describe. The society might occupy these buildings which do not move.\nOf course buildings do move, say in response to earthquakes but most are stationary.\nTo explain that society of electrons in toto we need to find out about each and every member of that society.\nThis is akin to doing a thorough census. Or say a novel with a third person omniscient view in which the author, writes a gigantic Tolstoyan work, going into the motivations of every character.\nThat would be a detailed work and it would tell us what the society is fundamentally like, its ground state energy.\nBut say you are only interested in this fundamental aspect of society, not in the story of every single electron. Well what can you do?\nExactly what Kohn and Sham did.\nTo describe what the common denominator of that society is, you can move to a first person point of view.\nYou find out how that one member of society relates to other members of the society (taking society in a smeared out, abstracted sense). You find out how that one person interacts with all the buildings.\nBut since you are now not taking all the members your results would have an uncertainty. You would have to make presumptions to take into account the unique quirks of that individual.\nYou lump all that in the \\(E_XC\\) term. But if you’re making assumptions about what that unique person is then society’s interaction with that individual electron are mediated through his quirky behavior. So you have to explore his character, reducing his unique traits to a minimum.\nWhen you’ve removed all those contributions, in a sensible way you will have all the different mental states and moods of the central character of your novel.\nKohn-Sham are essentially saying that if you pin down an individual’s unique traits and are able to negate them, you will have the same picture of what the society is fundamentally like; that you would have had if you’d taken the sum over all the individual members."
  },
  {
    "objectID": "C0manybody/home_manybody.html",
    "href": "C0manybody/home_manybody.html",
    "title": "Many-Body Systems",
    "section": "",
    "text": "Green’s functions/Propagators\nLinear response"
  },
  {
    "objectID": "C0manybody/home_manybody.html#chapters",
    "href": "C0manybody/home_manybody.html#chapters",
    "title": "Many-Body Systems",
    "section": "",
    "text": "Green’s functions/Propagators\nLinear response"
  },
  {
    "objectID": "C0manybody/lectures/homogeneouselectrongas.html",
    "href": "C0manybody/lectures/homogeneouselectrongas.html",
    "title": "HEG/jellium",
    "section": "",
    "text": "For the study of electrons in solids, a popular basis set is plane waves. Eigenstates are described by \\((p, \\sigma)\\), where \\(\\sigma\\) is the spin index, which is ±1 for spin up or down. The Hamiltonian then has the form:\n[Mahan, 1.160] H = On site energy + Interaction b/w electionrs and atoms or ions + electron-electron interaction.\n\\[\n\\text{Electron Density Operator} = \\rho(q) = \\Sigma_{k\\sigma} c_{k+q\\sigma}^{\\dagger}c_{k\\sigma}\n\\]\nProblem: Too complicated a Hamiltonian.\nSolution: Use a simpler model e.g. HEG which gets rid of the middle term.\n[Mahan, 1.164] H_HEG = On site energy + electron-electron interaction.\nReplaces atoms with a uniform positive background charge of density \\(n_o\\). To preserve charge neutrality, the average particle density of the electron gas must also be \\(n_o\\).\nQuestion: What is \\(n_o\\), the average density:\nIt’s the \\(q=0\\) value of the density operator.\n\\[\nn_o = \\frac{1}{\\nu} \\langle \\rho (q=0) \\rangle = \\frac{1}{\\nu} \\Sigma_{p\\sigma}N_p = \\frac{N_e}{\\nu}\n\\]"
  },
  {
    "objectID": "C0manybody/lectures/homogeneouselectrongas.html#sources",
    "href": "C0manybody/lectures/homogeneouselectrongas.html#sources",
    "title": "HEG/jellium",
    "section": "Sources",
    "text": "Sources\n\nMahan. Many Particle Physics."
  },
  {
    "objectID": "C0manybody/lectures/kohnsham.html",
    "href": "C0manybody/lectures/kohnsham.html",
    "title": "Kohn Sham Equations",
    "section": "",
    "text": "There is an analogy that I’d like to create between the many body quantum electronic hamiltonian and the Kohn-Sham equations.\nLike all analogies it would be woefully skimpy on details but when I first started out I thought it was a useful way of looking at things. That and the fact that I like to recast equations into stories.\nConsider the complete many-body electronic hamiltonian:\n\\[\nMany body hamiltonian\n\\]\nI like to think of this way. We have a society of electrons that we would like to describe. The society might occupy these buildings which do not move.\nOf course buildings do move, say in response to earthquakes but most are stationary.\nTo explain that society of electrons in toto we need to find out about each and every member of that society.\nThis is akin to doing a thorough census. Or say a novel with a third person omniscient view in which the author, writes a gigantic Tolstoyan work, going into the motivations of every character.\nThat would be a detailed work and it would tell us what the society is fundamentally like, its ground state energy.\nBut say you are only interested in this fundamental aspect of society, not in the story of every single electron. Well what can you do?\nExactly what Kohn and Sham did.\nTo describe what the common denominator of that society is, you can move to a first person point of view.\nYou find out how that one member of society relates to other members of the society (taking society in a smeared out, abstracted sense). You find out how that one person interacts with all the buildings.\nBut since you are now not taking all the members your results would have an uncertainty. You would have to make presumptions to take into account the unique quirks of that individual.\nYou lump all that in the \\(E_XC\\) term. But if you’re making assumptions about what that unique person is then society’s interaction with that individual electron are mediated through his quirky behavior. So you have to explore his character, reducing his unique traits to a minimum.\nWhen you’ve removed all those contributions, in a sensible way you will have all the different mental states and moods of the central character of your novel.\nKohn-Sham are essentially saying that if you pin down an individual’s unique traits and are able to negate them, you will have the same picture of what the society is fundamentally like; that you would have had if you’d taken the sum over all the individual members."
  },
  {
    "objectID": "C0manybody/lectures/greensfunctions.html",
    "href": "C0manybody/lectures/greensfunctions.html",
    "title": "Green’s Functions in Many-Body Theory",
    "section": "",
    "text": "One and two particle Green’s functions"
  },
  {
    "objectID": "C0manybody/lectures/greensfunctions.html#correlation-functions",
    "href": "C0manybody/lectures/greensfunctions.html#correlation-functions",
    "title": "Green’s Functions in Many-Body Theory",
    "section": "",
    "text": "One and two particle Green’s functions"
  },
  {
    "objectID": "C0manybody/lectures/greensfunctions.html#further-readings",
    "href": "C0manybody/lectures/greensfunctions.html#further-readings",
    "title": "Green’s Functions in Many-Body Theory",
    "section": "Further Readings",
    "text": "Further Readings"
  },
  {
    "objectID": "C0manybody/lectures/greensfunctions.html#sources",
    "href": "C0manybody/lectures/greensfunctions.html#sources",
    "title": "Green’s Functions in Many-Body Theory",
    "section": "Sources",
    "text": "Sources\n\nMartin. Interacting Electrons."
  },
  {
    "objectID": "C0manybody/lectures/exchangecorrelation.html",
    "href": "C0manybody/lectures/exchangecorrelation.html",
    "title": "Exchange & Correlation",
    "section": "",
    "text": "\\[\n\\hat{H} = \\sum_{\\mathbf{k},\\sigma} \\frac{\\hbar^2 k^2}{2m} c_{\\mathbf{k},\\sigma}^\\dagger c_{\\mathbf{k},\\sigma}\n+ \\frac{1}{2} \\sum_{\\mathbf{q} \\neq 0} v(\\mathbf{q}) \\sum_{\\mathbf{k},\\mathbf{k'},\\sigma,\\sigma'}\nc_{\\mathbf{k+q},\\sigma}^\\dagger c_{\\mathbf{k'-q},\\sigma'}^\\dagger c_{\\mathbf{k'},\\sigma'} c_{\\mathbf{k},\\sigma}\n\\]\nwhere \\(v(q) = 4 \\pi e^2/q^2\\).\nTwo electronic properties - Self energy of an electron of momentum p - Total Energy of the system: Electrons averaged to obtain the total energy of the system. This average is done at zero temperature. Find: ground state energy per particle \\(E_g = E_g(n_o)\\).\n== Mahan, 5.4\nIn the homogeneous electron gas, the average kinetic energy of the electrons is going to be proportional to EF ~ (K.E.) ~ k~, which, by dimensional analysis, is inversely proportional to the square of the characteristic length of the system, which is rs. Therefore (K.E.) ()( 1/“;. Similarly, dimensional analysis suggests that the average Coulomb energy per particle will be e’2 divided by the characteristic length, or (P.E.) ()( l/rs’ When the electron gas has suffi- ciently high density, which is small rs , the kinetic energy term will be larger than the potential energy term. In this case, the electrons will behave as free particles, since the potential energy is a perturbation on the dominant kinetic energy. In the high-density limit, the free-particle picture is expected to be valid"
  },
  {
    "objectID": "C0manybody/lectures/exchangecorrelation.html#jellium-model",
    "href": "C0manybody/lectures/exchangecorrelation.html#jellium-model",
    "title": "Exchange & Correlation",
    "section": "",
    "text": "\\[\n\\hat{H} = \\sum_{\\mathbf{k},\\sigma} \\frac{\\hbar^2 k^2}{2m} c_{\\mathbf{k},\\sigma}^\\dagger c_{\\mathbf{k},\\sigma}\n+ \\frac{1}{2} \\sum_{\\mathbf{q} \\neq 0} v(\\mathbf{q}) \\sum_{\\mathbf{k},\\mathbf{k'},\\sigma,\\sigma'}\nc_{\\mathbf{k+q},\\sigma}^\\dagger c_{\\mathbf{k'-q},\\sigma'}^\\dagger c_{\\mathbf{k'},\\sigma'} c_{\\mathbf{k},\\sigma}\n\\]\nwhere \\(v(q) = 4 \\pi e^2/q^2\\).\nTwo electronic properties - Self energy of an electron of momentum p - Total Energy of the system: Electrons averaged to obtain the total energy of the system. This average is done at zero temperature. Find: ground state energy per particle \\(E_g = E_g(n_o)\\).\n== Mahan, 5.4\nIn the homogeneous electron gas, the average kinetic energy of the electrons is going to be proportional to EF ~ (K.E.) ~ k~, which, by dimensional analysis, is inversely proportional to the square of the characteristic length of the system, which is rs. Therefore (K.E.) ()( 1/“;. Similarly, dimensional analysis suggests that the average Coulomb energy per particle will be e’2 divided by the characteristic length, or (P.E.) ()( l/rs’ When the electron gas has suffi- ciently high density, which is small rs , the kinetic energy term will be larger than the potential energy term. In this case, the electrons will behave as free particles, since the potential energy is a perturbation on the dominant kinetic energy. In the high-density limit, the free-particle picture is expected to be valid"
  },
  {
    "objectID": "C0manybody/lectures/exchangecorrelation.html#two-limits",
    "href": "C0manybody/lectures/exchangecorrelation.html#two-limits",
    "title": "Exchange & Correlation",
    "section": "Two limits",
    "text": "Two limits\n\nHigh density limit: KE &gt;&gt; PE (free particle)\nLow density limit KE &lt; PE"
  },
  {
    "objectID": "C0manybody/lectures/exchangecorrelation.html#energy-contributions",
    "href": "C0manybody/lectures/exchangecorrelation.html#energy-contributions",
    "title": "Exchange & Correlation",
    "section": "Energy Contributions",
    "text": "Energy Contributions\n\nKinetic\n[Mahan 5.7]\n\n\nHartree\nAll the remaining terms in the energy come from the Coulomb interaction between the particles. This contribution is not evaluated exactly. Instead, approximate expressions are used.\nUsing perturbation theory: the first term which occurs is the Coulomb interaction between the electrons and the uniform positive background, which is called the Hartree interaction given by:\n\\[\nN_e E_o = (e^2/2) \\int \\frac{d^3r_1 d^3r_2}{|r_1 - r_2|} [\\rho_e(r_1) - \\rho_i(r_1)][\\rho_e(r_2) - \\rho_i(r_2)]\n\\]\nIn the HEG: - the time-averaged electron density is uniform throughout the system, as is the positive background. - these equal and opposite charge densities exactly cancel, so that the net system is charge neutral. - Thus the Hartree energy is zero.\n\n\nExchange\nThe Hartree term corresponds to the following pairing of the operators in (5.1)\nThis term is called the exchange energy, or the Fock energy. Retaining both terms is called Hartree-Fock.\nExchange energy: gives a contribution to the energy of an individual electron, as well as a contribution to the ground state energy of the collection of electrons:\nHartree-Fock theory: Kinetic energy + the Hartree energy which is zero + the exchange energy\nCorrelation energy: energy tenus beyond Hartree-Fock. The name is applied both to the additional energy tenus in the self-energy of an electron of wave vector k, and to the ground state energy obtained by averaging over all of the electrons\n[Mahan, 5.31] Ee = -0.094 + 0.06221n(rs) + O(rs)\nThe tenu correlation energy is often applied to other quantities besides the total ground state energy. For example, the correlation energy of a particle of wave vector k are those tenus beyond Hartree-Fock:"
  },
  {
    "objectID": "C0ode/lectures/02-Summaryof1stODE.html",
    "href": "C0ode/lectures/02-Summaryof1stODE.html",
    "title": "Summary of 1st Order ODEs",
    "section": "",
    "text": "See this for a summary of 1st order ODEs."
  }
]